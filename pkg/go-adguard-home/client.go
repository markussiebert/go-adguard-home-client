// Package adguardhome provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package adguardhome

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for CheckConfigStaticIpInfoStatic.
const (
	CheckConfigStaticIpInfoStaticError CheckConfigStaticIpInfoStatic = "error"
	CheckConfigStaticIpInfoStaticNo    CheckConfigStaticIpInfoStatic = "no"
	CheckConfigStaticIpInfoStaticYes   CheckConfigStaticIpInfoStatic = "yes"
)

// Defines values for DNSConfigBlockingMode.
const (
	CustomIp DNSConfigBlockingMode = "custom_ip"
	Default  DNSConfigBlockingMode = "default"
	NullIp   DNSConfigBlockingMode = "null_ip"
	Nxdomain DNSConfigBlockingMode = "nxdomain"
	Refused  DNSConfigBlockingMode = "refused"
)

// Defines values for DhcpSearchResultOtherServerFound.
const (
	DhcpSearchResultOtherServerFoundError DhcpSearchResultOtherServerFound = "error"
	DhcpSearchResultOtherServerFoundNo    DhcpSearchResultOtherServerFound = "no"
	DhcpSearchResultOtherServerFoundYes   DhcpSearchResultOtherServerFound = "yes"
)

// Defines values for DhcpSearchResultStaticIPStatic.
const (
	DhcpSearchResultStaticIPStaticError DhcpSearchResultStaticIPStatic = "error"
	DhcpSearchResultStaticIPStaticNo    DhcpSearchResultStaticIPStatic = "no"
	DhcpSearchResultStaticIPStaticYes   DhcpSearchResultStaticIPStatic = "yes"
)

// Defines values for FilterCheckHostResponseReason.
const (
	FilterCheckHostResponseReasonFilteredBlackList      FilterCheckHostResponseReason = "FilteredBlackList"
	FilterCheckHostResponseReasonFilteredBlockedService FilterCheckHostResponseReason = "FilteredBlockedService"
	FilterCheckHostResponseReasonFilteredInvalid        FilterCheckHostResponseReason = "FilteredInvalid"
	FilterCheckHostResponseReasonFilteredParental       FilterCheckHostResponseReason = "FilteredParental"
	FilterCheckHostResponseReasonFilteredSafeBrowsing   FilterCheckHostResponseReason = "FilteredSafeBrowsing"
	FilterCheckHostResponseReasonFilteredSafeSearch     FilterCheckHostResponseReason = "FilteredSafeSearch"
	FilterCheckHostResponseReasonNotFilteredError       FilterCheckHostResponseReason = "NotFilteredError"
	FilterCheckHostResponseReasonNotFilteredNotFound    FilterCheckHostResponseReason = "NotFilteredNotFound"
	FilterCheckHostResponseReasonNotFilteredWhiteList   FilterCheckHostResponseReason = "NotFilteredWhiteList"
	FilterCheckHostResponseReasonRewrite                FilterCheckHostResponseReason = "Rewrite"
	FilterCheckHostResponseReasonRewriteEtcHosts        FilterCheckHostResponseReason = "RewriteEtcHosts"
	FilterCheckHostResponseReasonRewriteRule            FilterCheckHostResponseReason = "RewriteRule"
)

// Defines values for QueryLogConfigInterval.
const (
	QueryLogConfigIntervalN025 QueryLogConfigInterval = 0.25
	QueryLogConfigIntervalN1   QueryLogConfigInterval = 1
	QueryLogConfigIntervalN30  QueryLogConfigInterval = 30
	QueryLogConfigIntervalN7   QueryLogConfigInterval = 7
	QueryLogConfigIntervalN90  QueryLogConfigInterval = 90
)

// Defines values for QueryLogItemReason.
const (
	QueryLogItemReasonFilteredBlackList      QueryLogItemReason = "FilteredBlackList"
	QueryLogItemReasonFilteredBlockedService QueryLogItemReason = "FilteredBlockedService"
	QueryLogItemReasonFilteredInvalid        QueryLogItemReason = "FilteredInvalid"
	QueryLogItemReasonFilteredParental       QueryLogItemReason = "FilteredParental"
	QueryLogItemReasonFilteredSafeBrowsing   QueryLogItemReason = "FilteredSafeBrowsing"
	QueryLogItemReasonFilteredSafeSearch     QueryLogItemReason = "FilteredSafeSearch"
	QueryLogItemReasonNotFilteredError       QueryLogItemReason = "NotFilteredError"
	QueryLogItemReasonNotFilteredNotFound    QueryLogItemReason = "NotFilteredNotFound"
	QueryLogItemReasonNotFilteredWhiteList   QueryLogItemReason = "NotFilteredWhiteList"
	QueryLogItemReasonRewrite                QueryLogItemReason = "Rewrite"
	QueryLogItemReasonRewriteEtcHosts        QueryLogItemReason = "RewriteEtcHosts"
	QueryLogItemReasonRewriteRule            QueryLogItemReason = "RewriteRule"
)

// Defines values for StatsTimeUnits.
const (
	Days  StatsTimeUnits = "days"
	Hours StatsTimeUnits = "hours"
)

// Defines values for StatsConfigInterval.
const (
	StatsConfigIntervalN0  StatsConfigInterval = 0
	StatsConfigIntervalN1  StatsConfigInterval = 1
	StatsConfigIntervalN30 StatsConfigInterval = 30
	StatsConfigIntervalN7  StatsConfigInterval = 7
	StatsConfigIntervalN90 StatsConfigInterval = 90
)

// Defines values for TlsConfigKeyType.
const (
	ECDSA TlsConfigKeyType = "ECDSA"
	RSA   TlsConfigKeyType = "RSA"
)

// Defines values for QueryLogParamsResponseStatus.
const (
	All                 QueryLogParamsResponseStatus = "all"
	Blocked             QueryLogParamsResponseStatus = "blocked"
	BlockedParental     QueryLogParamsResponseStatus = "blocked_parental"
	BlockedSafebrowsing QueryLogParamsResponseStatus = "blocked_safebrowsing"
	Filtered            QueryLogParamsResponseStatus = "filtered"
	Processed           QueryLogParamsResponseStatus = "processed"
	Rewritten           QueryLogParamsResponseStatus = "rewritten"
	SafeSearch          QueryLogParamsResponseStatus = "safe_search"
	Whitelisted         QueryLogParamsResponseStatus = "whitelisted"
)

// AccessList Client and host access list.  Each of the lists should contain only unique elements.  In addition, allowed and disallowed lists cannot contain the same elements.
type AccessList struct {
	// AllowedClients The allowlist of clients: IP addresses, CIDRs, or ClientIDs.
	AllowedClients *[]string `json:"allowed_clients,omitempty"`

	// BlockedHosts The blocklist of hosts.
	BlockedHosts *[]string `json:"blocked_hosts,omitempty"`

	// DisallowedClients The blocklist of clients: IP addresses, CIDRs, or ClientIDs.
	DisallowedClients *[]string `json:"disallowed_clients,omitempty"`
}

// AccessListResponse Client and host access list.  Each of the lists should contain only unique elements.  In addition, allowed and disallowed lists cannot contain the same elements.
type AccessListResponseType = AccessList

// AccessSetRequest Client and host access list.  Each of the lists should contain only unique elements.  In addition, allowed and disallowed lists cannot contain the same elements.
type AccessSetRequest = AccessList

// AddUrlRequest /add_url request data
type AddUrlRequest struct {
	Name *string `json:"name,omitempty"`

	// Url URL or an absolute path to the file containing filtering rules.
	Url       *string `json:"url,omitempty"`
	Whitelist *bool   `json:"whitelist,omitempty"`
}

// AddressInfo Port information
type AddressInfo struct {
	Ip   string `json:"ip"`
	Port uint16 `json:"port"`
}

// AddressInfoBeta Port information
type AddressInfoBeta struct {
	Ip   []string `json:"ip"`
	Port uint16   `json:"port"`
}

// AddressesInfo AdGuard Home addresses configuration
type AddressesInfo struct {
	DnsPort uint16 `json:"dns_port"`

	// Interfaces Network interfaces dictionary, keys are interface names.
	Interfaces NetInterfaces `json:"interfaces"`
	Version    string        `json:"version"`
	WebPort    uint16        `json:"web_port"`
}

// AddressesInfoBeta AdGuard Home addresses configuration
type AddressesInfoBeta struct {
	DnsPort uint16 `json:"dns_port"`

	// Interfaces Network interfaces dictionary, keys are interface names.
	Interfaces []NetInterface `json:"interfaces"`
	WebPort    uint16         `json:"web_port"`
}

// BlockedService defines model for BlockedService.
type BlockedService struct {
	// IconSvg The SVG icon as a Base64-encoded string to make it easier to embed it into a data URL.
	IconSvg string `json:"icon_svg"`

	// Id The ID of this service.
	Id string `json:"id"`

	// Name The human-readable name of this service.
	Name string `json:"name"`

	// Rules The array of the filtering rules.
	Rules []string `json:"rules"`
}

// BlockedServicesAll defines model for BlockedServicesAll.
type BlockedServicesAll struct {
	BlockedServices []BlockedService `json:"blocked_services"`
}

// BlockedServicesArray defines model for BlockedServicesArray.
type BlockedServicesArray = []string

// CheckConfigRequest Configuration to be checked
type CheckConfigRequest struct {
	Dns         *CheckConfigRequestInfo `json:"dns,omitempty"`
	SetStaticIp *bool                   `json:"set_static_ip,omitempty"`
	Web         *CheckConfigRequestInfo `json:"web,omitempty"`
}

// CheckConfigRequestBeta Configuration to be checked
type CheckConfigRequestBeta struct {
	Dns         *CheckConfigRequestInfoBeta `json:"dns,omitempty"`
	SetStaticIp *bool                       `json:"set_static_ip,omitempty"`
	Web         *CheckConfigRequestInfoBeta `json:"web,omitempty"`
}

// CheckConfigRequestInfo defines model for CheckConfigRequestInfo.
type CheckConfigRequestInfo struct {
	Autofix *bool   `json:"autofix,omitempty"`
	Ip      *string `json:"ip,omitempty"`
	Port    *uint16 `json:"port,omitempty"`
}

// CheckConfigRequestInfoBeta defines model for CheckConfigRequestInfoBeta.
type CheckConfigRequestInfoBeta struct {
	Autofix *bool     `json:"autofix,omitempty"`
	Ip      *[]string `json:"ip,omitempty"`
	Port    *uint16   `json:"port,omitempty"`
}

// CheckConfigResponse defines model for CheckConfigResponse.
type CheckConfigResponse struct {
	Dns      CheckConfigResponseInfo `json:"dns"`
	StaticIp CheckConfigStaticIpInfo `json:"static_ip"`
	Web      CheckConfigResponseInfo `json:"web"`
}

// CheckConfigResponseInfo defines model for CheckConfigResponseInfo.
type CheckConfigResponseInfo struct {
	CanAutofix bool   `json:"can_autofix"`
	Status     string `json:"status"`
}

// CheckConfigStaticIpInfo defines model for CheckConfigStaticIpInfo.
type CheckConfigStaticIpInfo struct {
	// Error Error text. Set if static=error
	Error *string `json:"error,omitempty"`

	// Ip Current dynamic IP address. Set if static=no
	Ip *string `json:"ip,omitempty"`

	// Static Can be: yes, no, error
	Static *CheckConfigStaticIpInfoStatic `json:"static,omitempty"`
}

// CheckConfigStaticIpInfoStatic Can be: yes, no, error
type CheckConfigStaticIpInfoStatic string

// Client Client information.
type Client struct {
	BlockedServices  *[]string `json:"blocked_services,omitempty"`
	FilteringEnabled *bool     `json:"filtering_enabled,omitempty"`

	// Ids IP, CIDR, MAC, or ClientID.
	Ids *[]string `json:"ids,omitempty"`

	// Name Name
	Name                     *string   `json:"name,omitempty"`
	ParentalEnabled          *bool     `json:"parental_enabled,omitempty"`
	SafebrowsingEnabled      *bool     `json:"safebrowsing_enabled,omitempty"`
	SafesearchEnabled        *bool     `json:"safesearch_enabled,omitempty"`
	Tags                     *[]string `json:"tags,omitempty"`
	Upstreams                *[]string `json:"upstreams,omitempty"`
	UseGlobalBlockedServices *bool     `json:"use_global_blocked_services,omitempty"`
	UseGlobalSettings        *bool     `json:"use_global_settings,omitempty"`
}

// ClientAuto Auto-Client information
type ClientAuto struct {
	// Ip IP address
	Ip *string `json:"ip,omitempty"`

	// Name Name
	Name *string `json:"name,omitempty"`

	// Source The source of this information
	Source    *string    `json:"source,omitempty"`
	WhoisInfo *WhoisInfo `json:"whois_info,omitempty"`
}

// ClientDelete Client delete request
type ClientDelete struct {
	Name *string `json:"name,omitempty"`
}

// ClientFindSubEntry Client information.
type ClientFindSubEntry struct {
	BlockedServices *[]string `json:"blocked_services,omitempty"`

	// Disallowed Whether the client's IP is blocked or not.
	Disallowed *bool `json:"disallowed,omitempty"`

	// DisallowedRule The rule due to which the client is disallowed.  If disallowed is set to true, and this string is empty, then the client IP is disallowed by the "allowed IP list", that is it is not included in the allowed list.
	DisallowedRule   *string `json:"disallowed_rule,omitempty"`
	FilteringEnabled *bool   `json:"filtering_enabled,omitempty"`

	// Ids IP, CIDR, MAC, or ClientID.
	Ids *[]string `json:"ids,omitempty"`

	// Name Name
	Name                     *string    `json:"name,omitempty"`
	ParentalEnabled          *bool      `json:"parental_enabled,omitempty"`
	SafebrowsingEnabled      *bool      `json:"safebrowsing_enabled,omitempty"`
	SafesearchEnabled        *bool      `json:"safesearch_enabled,omitempty"`
	Upstreams                *[]string  `json:"upstreams,omitempty"`
	UseGlobalBlockedServices *bool      `json:"use_global_blocked_services,omitempty"`
	UseGlobalSettings        *bool      `json:"use_global_settings,omitempty"`
	WhoisInfo                *WhoisInfo `json:"whois_info,omitempty"`
}

// ClientUpdate Client update request
type ClientUpdate struct {
	// Data Client information.
	Data *Client `json:"data,omitempty"`
	Name *string `json:"name,omitempty"`
}

// Clients defines model for Clients.
type Clients struct {
	// AutoClients Auto-Clients array
	AutoClients *ClientsAutoArray `json:"auto_clients,omitempty"`

	// Clients Clients array
	Clients       *ClientsArray `json:"clients,omitempty"`
	SupportedTags *[]string     `json:"supported_tags,omitempty"`
}

// ClientsArray Clients array
type ClientsArray = []Client

// ClientsAutoArray Auto-Clients array
type ClientsAutoArray = []ClientAuto

// ClientsFindEntry defines model for ClientsFindEntry.
type ClientsFindEntry map[string]ClientFindSubEntry

// ClientsFindResponseType Client search results.
type ClientsFindResponseType = []ClientsFindEntry

// DNSConfig Query log configuration
type DNSConfig struct {
	BlockingIpv4 *string                `json:"blocking_ipv4,omitempty"`
	BlockingIpv6 *string                `json:"blocking_ipv6,omitempty"`
	BlockingMode *DNSConfigBlockingMode `json:"blocking_mode,omitempty"`

	// BootstrapDns Bootstrap servers, port is optional after colon.  Empty value will reset it to default values.
	BootstrapDns    *[]string `json:"bootstrap_dns,omitempty"`
	CacheOptimistic *bool     `json:"cache_optimistic,omitempty"`
	CacheSize       *int      `json:"cache_size,omitempty"`
	CacheTtlMax     *int      `json:"cache_ttl_max,omitempty"`
	CacheTtlMin     *int      `json:"cache_ttl_min,omitempty"`
	DhcpAvailable   *bool     `json:"dhcp_available,omitempty"`
	DisableIpv6     *bool     `json:"disable_ipv6,omitempty"`
	DnssecEnabled   *bool     `json:"dnssec_enabled,omitempty"`
	EdnsCsEnabled   *bool     `json:"edns_cs_enabled,omitempty"`

	// LocalPtrUpstreams Upstream servers, port is optional after colon.  Empty value will reset it to default values.
	LocalPtrUpstreams *[]string `json:"local_ptr_upstreams,omitempty"`
	ProtectionEnabled *bool     `json:"protection_enabled,omitempty"`
	Ratelimit         *int      `json:"ratelimit,omitempty"`
	ResolveClients    *bool     `json:"resolve_clients,omitempty"`

	// UpstreamDns Upstream servers, port is optional after colon.  Empty value will reset it to default values.
	UpstreamDns            *[]string    `json:"upstream_dns,omitempty"`
	UpstreamDnsFile        *string      `json:"upstream_dns_file,omitempty"`
	UpstreamMode           *interface{} `json:"upstream_mode,omitempty"`
	UsePrivatePtrResolvers *bool        `json:"use_private_ptr_resolvers,omitempty"`
}

// DNSConfigBlockingMode defines model for DNSConfig.BlockingMode.
type DNSConfigBlockingMode string

// DhcpConfig defines model for DhcpConfig.
type DhcpConfig struct {
	Enabled       *bool         `json:"enabled,omitempty"`
	InterfaceName *string       `json:"interface_name,omitempty"`
	V4            *DhcpConfigV4 `json:"v4,omitempty"`
	V6            *DhcpConfigV6 `json:"v6,omitempty"`
}

// DhcpConfigV4 defines model for DhcpConfigV4.
type DhcpConfigV4 struct {
	GatewayIp     *string `json:"gateway_ip,omitempty"`
	LeaseDuration *int    `json:"lease_duration,omitempty"`
	RangeEnd      *string `json:"range_end,omitempty"`
	RangeStart    *string `json:"range_start,omitempty"`
	SubnetMask    *string `json:"subnet_mask,omitempty"`
}

// DhcpConfigV6 defines model for DhcpConfigV6.
type DhcpConfigV6 struct {
	LeaseDuration *int    `json:"lease_duration,omitempty"`
	RangeStart    *string `json:"range_start,omitempty"`
}

// DhcpFindActiveReq Request for checking for other DHCP servers in the network.
type DhcpFindActiveReq struct {
	// Interface The name of the network interface
	Interface *string `json:"interface,omitempty"`
}

// DhcpLease DHCP lease information
type DhcpLease struct {
	Expires  string `json:"expires"`
	Hostname string `json:"hostname"`
	Ip       string `json:"ip"`
	Mac      string `json:"mac"`
}

// DhcpSearchResult Information about a DHCP server discovered in the current network.
type DhcpSearchResult struct {
	V4 *DhcpSearchV4 `json:"v4,omitempty"`
	V6 *DhcpSearchV6 `json:"v6,omitempty"`
}

// DhcpSearchResultOtherServer defines model for DhcpSearchResultOtherServer.
type DhcpSearchResultOtherServer struct {
	// Error Set if found=error
	Error *string `json:"error,omitempty"`

	// Found The result of searching the other DHCP server.
	Found *DhcpSearchResultOtherServerFound `json:"found,omitempty"`
}

// DhcpSearchResultOtherServerFound The result of searching the other DHCP server.
type DhcpSearchResultOtherServerFound string

// DhcpSearchResultStaticIP defines model for DhcpSearchResultStaticIP.
type DhcpSearchResultStaticIP struct {
	// Ip Set if static=no
	Ip *string `json:"ip,omitempty"`

	// Static The result of determining static IP address.
	Static *DhcpSearchResultStaticIPStatic `json:"static,omitempty"`
}

// DhcpSearchResultStaticIPStatic The result of determining static IP address.
type DhcpSearchResultStaticIPStatic string

// DhcpSearchV4 defines model for DhcpSearchV4.
type DhcpSearchV4 struct {
	OtherServer *DhcpSearchResultOtherServer `json:"other_server,omitempty"`
	StaticIp    *DhcpSearchResultStaticIP    `json:"static_ip,omitempty"`
}

// DhcpSearchV6 defines model for DhcpSearchV6.
type DhcpSearchV6 struct {
	OtherServer *DhcpSearchResultOtherServer `json:"other_server,omitempty"`
}

// DhcpStaticLease DHCP static lease information
type DhcpStaticLease struct {
	Hostname string `json:"hostname"`
	Ip       string `json:"ip"`
	Mac      string `json:"mac"`
}

// DhcpStatus Built-in DHCP server configuration and status
type DhcpStatus struct {
	Enabled       *bool              `json:"enabled,omitempty"`
	InterfaceName *string            `json:"interface_name,omitempty"`
	Leases        []DhcpLease        `json:"leases"`
	StaticLeases  *[]DhcpStaticLease `json:"static_leases,omitempty"`
	V4            *DhcpConfigV4      `json:"v4,omitempty"`
	V6            *DhcpConfigV6      `json:"v6,omitempty"`
}

// DnsAnswer DNS answer section
type DnsAnswer struct {
	Ttl   *uint32 `json:"ttl,omitempty"`
	Type  *string `json:"type,omitempty"`
	Value *string `json:"value,omitempty"`
}

// DnsQuestion DNS question section
type DnsQuestion struct {
	Class       *string `json:"class,omitempty"`
	Name        *string `json:"name,omitempty"`
	Type        *string `json:"type,omitempty"`
	UnicodeName *string `json:"unicode_name,omitempty"`
}

// Error A generic JSON error response.
type Error struct {
	// Message The error message, an opaque string.
	Message *string `json:"message,omitempty"`
}

// Filter Filter subscription info
type Filter struct {
	Enabled     bool       `json:"enabled"`
	Id          int64      `json:"id"`
	LastUpdated *time.Time `json:"last_updated,omitempty"`
	Name        string     `json:"name"`
	RulesCount  uint32     `json:"rules_count"`
	Url         string     `json:"url"`
}

// FilterCheckHostResponse Check Host Result
type FilterCheckHostResponse struct {
	// Cname Set if reason=Rewrite
	Cname *string `json:"cname,omitempty"`

	// FilterId In case if there's a rule applied to this DNS request, this is ID of the filter list that the rule belongs to.
	// Deprecated: use `rules[*].filter_list_id` instead.
	FilterId *int `json:"filter_id,omitempty"`

	// IpAddrs Set if reason=Rewrite
	IpAddrs *[]string `json:"ip_addrs,omitempty"`

	// Reason Request filtering status.
	Reason *FilterCheckHostResponseReason `json:"reason,omitempty"`

	// Rule Filtering rule applied to the request (if any).
	// Deprecated: use `rules[*].text` instead.
	Rule *string `json:"rule,omitempty"`

	// Rules Applied rules.
	Rules *[]ResultRule `json:"rules,omitempty"`

	// ServiceName Set if reason=FilteredBlockedService
	ServiceName *string `json:"service_name,omitempty"`
}

// FilterCheckHostResponseReason Request filtering status.
type FilterCheckHostResponseReason string

// FilterConfig Filtering settings
type FilterConfig struct {
	Enabled  *bool `json:"enabled,omitempty"`
	Interval *int  `json:"interval,omitempty"`
}

// FilterRefreshRequest Refresh Filters request data
type FilterRefreshRequest struct {
	Whitelist *bool `json:"whitelist,omitempty"`
}

// FilterRefreshResponse /filtering/refresh response data
type FilterRefreshResponse struct {
	Updated *int `json:"updated,omitempty"`
}

// FilterSetUrl Filtering URL settings
type FilterSetUrl struct {
	// Data Filter update data
	Data      *FilterSetUrlData `json:"data,omitempty"`
	Url       *string           `json:"url,omitempty"`
	Whitelist *bool             `json:"whitelist,omitempty"`
}

// FilterSetUrlData Filter update data
type FilterSetUrlData struct {
	Enabled bool   `json:"enabled"`
	Name    string `json:"name"`
	Url     string `json:"url"`
}

// FilterStatus Filtering settings
type FilterStatus struct {
	Enabled          *bool     `json:"enabled,omitempty"`
	Filters          *[]Filter `json:"filters,omitempty"`
	Interval         *int      `json:"interval,omitempty"`
	UserRules        *[]string `json:"user_rules,omitempty"`
	WhitelistFilters *[]Filter `json:"whitelist_filters,omitempty"`
}

// GetVersionRequest /version.json request data
type GetVersionRequest struct {
	// RecheckNow If false, server will check for a new version data only once in several hours.
	RecheckNow *bool `json:"recheck_now,omitempty"`
}

// InitialConfiguration AdGuard Home initial configuration for the first-install wizard.
type InitialConfiguration struct {
	// Dns Port information
	Dns AddressInfo `json:"dns"`

	// Password Basic auth password
	Password string `json:"password"`

	// Username Basic auth username
	Username string `json:"username"`

	// Web Port information
	Web AddressInfo `json:"web"`
}

// InitialConfigurationBeta AdGuard Home initial configuration for the first-install wizard.
type InitialConfigurationBeta struct {
	// Dns Port information
	Dns AddressInfoBeta `json:"dns"`

	// Password Basic auth password
	Password string `json:"password"`

	// Username Basic auth username
	Username string `json:"username"`

	// Web Port information
	Web AddressInfoBeta `json:"web"`
}

// LanguageSettings Language settings object.
type LanguageSettings struct {
	// Language The current language or the language to set.
	Language string `json:"language"`
}

// Login Login request data
type Login struct {
	// Name User name
	Name *string `json:"name,omitempty"`

	// Password Password
	Password *string `json:"password,omitempty"`
}

// NetInterface Network interface info
type NetInterface struct {
	// Flags Flags could be any combination of the following values, divided by the "|" character: "up", "broadcast", "loopback", "pointtopoint" and "multicast".
	Flags           string    `json:"flags"`
	HardwareAddress string    `json:"hardware_address"`
	IpAddresses     *[]string `json:"ip_addresses,omitempty"`
	Mtu             int       `json:"mtu"`
	Name            string    `json:"name"`
}

// NetInterfaces Network interfaces dictionary, keys are interface names.
type NetInterfaces map[string]NetInterface

// ProfileInfo Information about the current user
type ProfileInfo struct {
	Name *string `json:"name,omitempty"`
}

// QueryLog Query log
type QueryLog struct {
	Data   *[]QueryLogItem `json:"data,omitempty"`
	Oldest *string         `json:"oldest,omitempty"`
}

// QueryLogConfig Query log configuration
type QueryLogConfig struct {
	// AnonymizeClientIp Anonymize clients' IP addresses
	AnonymizeClientIp *bool `json:"anonymize_client_ip,omitempty"`

	// Enabled Is query log enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Interval Time period for query log rotation.
	Interval *QueryLogConfigInterval `json:"interval,omitempty"`
}

// QueryLogConfigInterval Time period for query log rotation.
type QueryLogConfigInterval float32

// QueryLogItem Query log item
type QueryLogItem struct {
	Answer *[]DnsAnswer `json:"answer,omitempty"`

	// AnswerDnssec If true, the response had the Authenticated Data (AD) flag set.
	AnswerDnssec *bool `json:"answer_dnssec,omitempty"`

	// Cached Defines if the response has been served from cache.
	Cached *bool `json:"cached,omitempty"`

	// Client The client's IP address.
	Client *string `json:"client,omitempty"`

	// ClientId The ClientID, if provided in DoH, DoQ, or DoT.
	ClientId *string `json:"client_id,omitempty"`

	// ClientInfo Client information for a query log item.
	ClientInfo  *QueryLogItemClient `json:"client_info,omitempty"`
	ClientProto *interface{}        `json:"client_proto,omitempty"`

	// Ecs The IP network defined by an EDNS Client-Subnet option in the request message if any.
	Ecs       *string `json:"ecs,omitempty"`
	ElapsedMs *string `json:"elapsedMs,omitempty"`

	// FilterId In case if there's a rule applied to this DNS request, this is ID of the filter list that the rule belongs to.
	// Deprecated: use `rules[*].filter_list_id` instead.
	FilterId *int `json:"filterId,omitempty"`

	// OriginalAnswer Answer from upstream server (optional)
	OriginalAnswer *[]DnsAnswer `json:"original_answer,omitempty"`

	// Question DNS question section
	Question *DnsQuestion `json:"question,omitempty"`

	// Reason Request filtering status.
	Reason *QueryLogItemReason `json:"reason,omitempty"`

	// Rule Filtering rule applied to the request (if any).
	// Deprecated: use `rules[*].text` instead.
	Rule *string `json:"rule,omitempty"`

	// Rules Applied rules.
	Rules *[]ResultRule `json:"rules,omitempty"`

	// ServiceName Set if reason=FilteredBlockedService
	ServiceName *string `json:"service_name,omitempty"`

	// Status DNS response status
	Status *string `json:"status,omitempty"`

	// Time DNS request processing start time
	Time *string `json:"time,omitempty"`

	// Upstream Upstream URL starting with tcp://, tls://, https://, or with an IP address.
	Upstream *string `json:"upstream,omitempty"`
}

// QueryLogItemReason Request filtering status.
type QueryLogItemReason string

// QueryLogItemClient Client information for a query log item.
type QueryLogItemClient struct {
	// Disallowed Whether the client's IP is blocked or not.
	Disallowed bool `json:"disallowed"`

	// DisallowedRule The rule due to which the client is allowed or blocked.
	DisallowedRule string `json:"disallowed_rule"`

	// Name Persistent client's name or runtime client's hostname.  May be empty.
	Name string `json:"name"`

	// Whois Client WHOIS information, if any.
	Whois QueryLogItemClientWhois `json:"whois"`
}

// QueryLogItemClientWhois Client WHOIS information, if any.
type QueryLogItemClientWhois struct {
	// City City, if any.
	City *string `json:"city,omitempty"`

	// Country Country, if any.
	Country *string `json:"country,omitempty"`

	// Orgname Organization name, if any.
	Orgname *string `json:"orgname,omitempty"`
}

// RemoveUrlRequest /remove_url request data
type RemoveUrlRequest struct {
	// Url Previously added URL containing filtering rules
	Url       *string `json:"url,omitempty"`
	Whitelist *bool   `json:"whitelist,omitempty"`
}

// ResultRule Applied rule.
type ResultRule struct {
	// FilterListId In case if there's a rule applied to this DNS request, this is ID of the filter list that the rule belongs to.
	FilterListId *int64 `json:"filter_list_id,omitempty"`

	// Text The text of the filtering rule applied to the request (if any).
	Text *string `json:"text,omitempty"`
}

// RewriteEntry Rewrite rule
type RewriteEntry struct {
	// Answer value of A, AAAA or CNAME DNS record
	Answer *string `json:"answer,omitempty"`

	// Domain Domain name
	Domain *string `json:"domain,omitempty"`
}

// RewriteList Rewrite rules array
type RewriteList = []RewriteEntry

// ServerStatus AdGuard Home server status and configuration
type ServerStatus struct {
	DhcpAvailable     *bool    `json:"dhcp_available,omitempty"`
	DnsAddresses      []string `json:"dns_addresses"`
	DnsPort           uint16   `json:"dns_port"`
	HttpPort          uint16   `json:"http_port"`
	Language          string   `json:"language"`
	ProtectionEnabled bool     `json:"protection_enabled"`
	Running           bool     `json:"running"`
	Version           string   `json:"version"`
}

// SetRulesRequest Custom filtering rules setting request.
type SetRulesRequest struct {
	Rules *[]string `json:"rules,omitempty"`
}

// Stats Server statistics data
type Stats struct {
	// AvgProcessingTime Average time in milliseconds on processing a DNS
	AvgProcessingTime *float32 `json:"avg_processing_time,omitempty"`
	BlockedFiltering  *[]int   `json:"blocked_filtering,omitempty"`
	DnsQueries        *[]int   `json:"dns_queries,omitempty"`

	// NumBlockedFiltering Number of requests blocked by filtering rules
	NumBlockedFiltering *int `json:"num_blocked_filtering,omitempty"`

	// NumDnsQueries Total number of DNS queries
	NumDnsQueries *int `json:"num_dns_queries,omitempty"`

	// NumReplacedParental Number of blocked adult websites
	NumReplacedParental *int `json:"num_replaced_parental,omitempty"`

	// NumReplacedSafebrowsing Number of requests blocked by safebrowsing module
	NumReplacedSafebrowsing *int `json:"num_replaced_safebrowsing,omitempty"`

	// NumReplacedSafesearch Number of requests blocked by safesearch module
	NumReplacedSafesearch *int   `json:"num_replaced_safesearch,omitempty"`
	ReplacedParental      *[]int `json:"replaced_parental,omitempty"`
	ReplacedSafebrowsing  *[]int `json:"replaced_safebrowsing,omitempty"`

	// TimeUnits Time units
	TimeUnits         *StatsTimeUnits  `json:"time_units,omitempty"`
	TopBlockedDomains *[]TopArrayEntry `json:"top_blocked_domains,omitempty"`
	TopClients        *[]TopArrayEntry `json:"top_clients,omitempty"`
	TopQueriedDomains *[]TopArrayEntry `json:"top_queried_domains,omitempty"`
}

// StatsTimeUnits Time units
type StatsTimeUnits string

// StatsConfig Statistics configuration
type StatsConfig struct {
	// Interval Time period to keep the data.  `0` means that the statistics is disabled.
	Interval *StatsConfigInterval `json:"interval,omitempty"`
}

// StatsConfigInterval Time period to keep the data.  `0` means that the statistics is disabled.
type StatsConfigInterval int

// TlsConfig TLS configuration settings and status
type TlsConfig struct {
	// CertificateChain Base64 string with PEM-encoded certificates chain
	CertificateChain *string `json:"certificate_chain,omitempty"`

	// CertificatePath Path to certificate file
	CertificatePath *string `json:"certificate_path,omitempty"`

	// DnsNames The value of SubjectAltNames field of the first certificate in the chain.
	DnsNames *[]string `json:"dns_names,omitempty"`

	// Enabled enabled is the encryption (DoT/DoH/HTTPS) status
	Enabled *bool `json:"enabled,omitempty"`

	// ForceHttps if true, forces HTTP->HTTPS redirect
	ForceHttps *bool `json:"force_https,omitempty"`

	// Issuer The issuer of the first certificate in the chain.
	Issuer *string `json:"issuer,omitempty"`

	// KeyType Key type.
	KeyType *TlsConfigKeyType `json:"key_type,omitempty"`

	// NotAfter The NotAfter field of the first certificate in the chain.
	NotAfter *string `json:"not_after,omitempty"`

	// NotBefore The NotBefore field of the first certificate in the chain.
	NotBefore *string `json:"not_before,omitempty"`

	// PortDnsOverQuic DNS-over-QUIC port. If 0, DoQ will be disabled.
	PortDnsOverQuic *uint16 `json:"port_dns_over_quic,omitempty"`

	// PortDnsOverTls DNS-over-TLS port. If 0, DoT will be disabled.
	PortDnsOverTls *uint16 `json:"port_dns_over_tls,omitempty"`

	// PortHttps HTTPS port. If 0, HTTPS will be disabled.
	PortHttps *uint16 `json:"port_https,omitempty"`

	// PrivateKey Base64 string with PEM-encoded private key
	PrivateKey *string `json:"private_key,omitempty"`

	// PrivateKeyPath Path to private key file
	PrivateKeyPath *string `json:"private_key_path,omitempty"`

	// PrivateKeySaved Set to true if the user has previously saved a private key as a string.  This is used so that the server and the client don't have to send the private key between each other every time, which might lead to security issues.
	PrivateKeySaved *bool `json:"private_key_saved,omitempty"`

	// ServerName server_name is the hostname of your HTTPS/TLS server
	ServerName *string `json:"server_name,omitempty"`

	// Subject The subject of the first certificate in the chain.
	Subject *string `json:"subject,omitempty"`

	// ValidCert Set to true if the specified certificates chain is a valid chain of X509 certificates.
	ValidCert *bool `json:"valid_cert,omitempty"`

	// ValidChain Set to true if the specified certificates chain is verified and issued by a known CA.
	ValidChain *bool `json:"valid_chain,omitempty"`

	// ValidKey Set to true if the key is a valid private key.
	ValidKey *bool `json:"valid_key,omitempty"`

	// ValidPair Set to true if both certificate and private key are correct.
	ValidPair *bool `json:"valid_pair,omitempty"`

	// WarningValidation A validation warning message with the issue description.
	WarningValidation *string `json:"warning_validation,omitempty"`
}

// TlsConfigKeyType Key type.
type TlsConfigKeyType string

// TopArrayEntry Represent the number of hits per key (domain or client IP).
type TopArrayEntry struct {
	DomainOrIp           *int           `json:"domain_or_ip,omitempty"`
	AdditionalProperties map[string]int `json:"-"`
}

// UpstreamsConfig Upstreams configuration
type UpstreamsConfig struct {
	// BootstrapDns Bootstrap servers, port is optional after colon.  Empty value will reset it to default values.
	BootstrapDns []string `json:"bootstrap_dns"`

	// PrivateUpstream Local PTR resolvers, port is optional after colon.  Empty value will reset it to default values.
	PrivateUpstream *[]string `json:"private_upstream,omitempty"`

	// UpstreamDns Upstream servers, port is optional after colon.  Empty value will reset it to default values.
	UpstreamDns []string `json:"upstream_dns"`
}

// UpstreamsConfigResponse Upstreams configuration response
type UpstreamsConfigResponse map[string]string

// VersionInfo Information about the latest available version of AdGuard Home.
type VersionInfo struct {
	Announcement    *string `json:"announcement,omitempty"`
	AnnouncementUrl *string `json:"announcement_url,omitempty"`
	CanAutoupdate   *bool   `json:"can_autoupdate,omitempty"`

	// Disabled If true then other fields doesn't appear.
	Disabled   bool    `json:"disabled"`
	NewVersion *string `json:"new_version,omitempty"`
}

// WhoisInfo defines model for WhoisInfo.
type WhoisInfo map[string]string

// DhcpStaticLeaseComponent DHCP static lease information
type DhcpStaticLeaseComponent = DhcpStaticLease

// RewriteEntryComponent Rewrite rule
type RewriteEntryComponent = RewriteEntry

// TlsConfigComponent TLS configuration settings and status
type TlsConfigComponent = TlsConfig

// MobileConfigDoHParams defines parameters for MobileConfigDoH.
type MobileConfigDoHParams struct {
	// Host Host for which the config is generated.  If no host is provided, `tls.server_name` from the configuration file is used.  If `tls.server_name` is not set, the API returns an error with a 500 status.
	Host string `form:"host" json:"host"`

	// ClientId ClientID.
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`
}

// MobileConfigDoTParams defines parameters for MobileConfigDoT.
type MobileConfigDoTParams struct {
	// Host Host for which the config is generated.  If no host is provided, `tls.server_name` from the configuration file is used.  If `tls.server_name` is not set, the API returns an error with a 500 status.
	Host string `form:"host" json:"host"`

	// ClientId ClientID.
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`
}

// ClientsFindParams defines parameters for ClientsFind.
type ClientsFindParams struct {
	// Ip0 Filter by IP address or ClientIDs.  Parameters with names `ip1`, `ip2`, and so on are also accepted and interpreted as "ip0 OR ip1 OR ip2".
	// TODO(a.garipov): Replace with a better query API.
	Ip0 *string `form:"ip0,omitempty" json:"ip0,omitempty"`
}

// FilteringCheckHostParams defines parameters for FilteringCheckHost.
type FilteringCheckHostParams struct {
	// Name Filter by host name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// QueryLogParams defines parameters for QueryLog.
type QueryLogParams struct {
	// OlderThan Filter by older than
	OlderThan *string `form:"older_than,omitempty" json:"older_than,omitempty"`

	// Offset Specify the ranking number of the first item on the page.  Even though it is possible to use "offset" and "older_than", we recommend choosing one of them and sticking to it.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of records to be returned
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Search Filter by domain name or client IP
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// ResponseStatus Filter by response status
	ResponseStatus *QueryLogParamsResponseStatus `form:"response_status,omitempty" json:"response_status,omitempty"`
}

// QueryLogParamsResponseStatus defines parameters for QueryLog.
type QueryLogParamsResponseStatus string

// AccessSetJSONRequestBody defines body for AccessSet for application/json ContentType.
type AccessSetJSONRequestBody = AccessSetRequest

// BlockedServicesSetJSONRequestBody defines body for BlockedServicesSet for application/json ContentType.
type BlockedServicesSetJSONRequestBody = BlockedServicesArray

// ClientsAddJSONRequestBody defines body for ClientsAdd for application/json ContentType.
type ClientsAddJSONRequestBody = Client

// ClientsDeleteJSONRequestBody defines body for ClientsDelete for application/json ContentType.
type ClientsDeleteJSONRequestBody = ClientDelete

// ClientsUpdateJSONRequestBody defines body for ClientsUpdate for application/json ContentType.
type ClientsUpdateJSONRequestBody = ClientUpdate

// DhcpAddStaticLeaseJSONRequestBody defines body for DhcpAddStaticLease for application/json ContentType.
type DhcpAddStaticLeaseJSONRequestBody = DhcpStaticLease

// CheckActiveDhcpJSONRequestBody defines body for CheckActiveDhcp for application/json ContentType.
type CheckActiveDhcpJSONRequestBody = DhcpFindActiveReq

// DhcpRemoveStaticLeaseJSONRequestBody defines body for DhcpRemoveStaticLease for application/json ContentType.
type DhcpRemoveStaticLeaseJSONRequestBody = DhcpStaticLease

// DhcpSetConfigJSONRequestBody defines body for DhcpSetConfig for application/json ContentType.
type DhcpSetConfigJSONRequestBody = DhcpConfig

// DnsConfigJSONRequestBody defines body for DnsConfig for application/json ContentType.
type DnsConfigJSONRequestBody = DNSConfig

// FilteringAddURLJSONRequestBody defines body for FilteringAddURL for application/json ContentType.
type FilteringAddURLJSONRequestBody = AddUrlRequest

// FilteringConfigJSONRequestBody defines body for FilteringConfig for application/json ContentType.
type FilteringConfigJSONRequestBody = FilterConfig

// FilteringRefreshJSONRequestBody defines body for FilteringRefresh for application/json ContentType.
type FilteringRefreshJSONRequestBody = FilterRefreshRequest

// FilteringRemoveURLJSONRequestBody defines body for FilteringRemoveURL for application/json ContentType.
type FilteringRemoveURLJSONRequestBody = RemoveUrlRequest

// FilteringSetRulesJSONRequestBody defines body for FilteringSetRules for application/json ContentType.
type FilteringSetRulesJSONRequestBody = SetRulesRequest

// FilteringSetURLJSONRequestBody defines body for FilteringSetURL for application/json ContentType.
type FilteringSetURLJSONRequestBody = FilterSetUrl

// ChangeLanguageJSONRequestBody defines body for ChangeLanguage for application/json ContentType.
type ChangeLanguageJSONRequestBody = LanguageSettings

// InstallCheckConfigJSONRequestBody defines body for InstallCheckConfig for application/json ContentType.
type InstallCheckConfigJSONRequestBody = CheckConfigRequest

// InstallCheckConfigBetaJSONRequestBody defines body for InstallCheckConfigBeta for application/json ContentType.
type InstallCheckConfigBetaJSONRequestBody = CheckConfigRequestBeta

// InstallConfigureJSONRequestBody defines body for InstallConfigure for application/json ContentType.
type InstallConfigureJSONRequestBody = InitialConfiguration

// InstallConfigureBetaJSONRequestBody defines body for InstallConfigureBeta for application/json ContentType.
type InstallConfigureBetaJSONRequestBody = InitialConfigurationBeta

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = Login

// QueryLogConfigJSONRequestBody defines body for QueryLogConfig for application/json ContentType.
type QueryLogConfigJSONRequestBody = QueryLogConfig

// RewriteAddJSONRequestBody defines body for RewriteAdd for application/json ContentType.
type RewriteAddJSONRequestBody = RewriteEntry

// RewriteDeleteJSONRequestBody defines body for RewriteDelete for application/json ContentType.
type RewriteDeleteJSONRequestBody = RewriteEntry

// StatsConfigJSONRequestBody defines body for StatsConfig for application/json ContentType.
type StatsConfigJSONRequestBody = StatsConfig

// TestUpstreamDNSJSONRequestBody defines body for TestUpstreamDNS for application/json ContentType.
type TestUpstreamDNSJSONRequestBody = UpstreamsConfig

// TlsConfigureJSONRequestBody defines body for TlsConfigure for application/json ContentType.
type TlsConfigureJSONRequestBody = TlsConfig

// TlsValidateJSONRequestBody defines body for TlsValidate for application/json ContentType.
type TlsValidateJSONRequestBody = TlsConfig

// GetVersionJsonJSONRequestBody defines body for GetVersionJson for application/json ContentType.
type GetVersionJsonJSONRequestBody = GetVersionRequest

// Getter for additional properties for TopArrayEntry. Returns the specified
// element and whether it was found
func (a TopArrayEntry) Get(fieldName string) (value int, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TopArrayEntry
func (a *TopArrayEntry) Set(fieldName string, value int) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]int)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TopArrayEntry to handle AdditionalProperties
func (a *TopArrayEntry) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["domain_or_ip"]; found {
		err = json.Unmarshal(raw, &a.DomainOrIp)
		if err != nil {
			return fmt.Errorf("error reading 'domain_or_ip': %w", err)
		}
		delete(object, "domain_or_ip")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]int)
		for fieldName, fieldBuf := range object {
			var fieldVal int
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TopArrayEntry to handle AdditionalProperties
func (a TopArrayEntry) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DomainOrIp != nil {
		object["domain_or_ip"], err = json.Marshal(a.DomainOrIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'domain_or_ip': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// AdguardHomeClient which conforms to the OpenAPI3 specification for this service.
type AdguardHomeClient struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*AdguardHomeClient) error

// Creates a new AdguardHomeClient, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*AdguardHomeClient, error) {
	// create a client with sane default values
	client := AdguardHomeClient{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *AdguardHomeClient) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *AdguardHomeClient) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AccessList request
	AccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccessSet request with any body
	AccessSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccessSet(ctx context.Context, body AccessSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MobileConfigDoH request
	MobileConfigDoH(ctx context.Context, params *MobileConfigDoHParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MobileConfigDoT request
	MobileConfigDoT(ctx context.Context, params *MobileConfigDoTParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesAll request
	BlockedServicesAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesList request
	BlockedServicesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesAvailableServices request
	BlockedServicesAvailableServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesSet request with any body
	BlockedServicesSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BlockedServicesSet(ctx context.Context, body BlockedServicesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheClear request
	CacheClear(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsStatus request
	ClientsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsAdd request with any body
	ClientsAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClientsAdd(ctx context.Context, body ClientsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsDelete request with any body
	ClientsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClientsDelete(ctx context.Context, body ClientsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsFind request
	ClientsFind(ctx context.Context, params *ClientsFindParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsUpdate request with any body
	ClientsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClientsUpdate(ctx context.Context, body ClientsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpAddStaticLease request with any body
	DhcpAddStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DhcpAddStaticLease(ctx context.Context, body DhcpAddStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckActiveDhcp request with any body
	CheckActiveDhcpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckActiveDhcp(ctx context.Context, body CheckActiveDhcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpInterfaces request
	DhcpInterfaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpRemoveStaticLease request with any body
	DhcpRemoveStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DhcpRemoveStaticLease(ctx context.Context, body DhcpRemoveStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpReset request
	DhcpReset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpResetLeases request
	DhcpResetLeases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpSetConfig request with any body
	DhcpSetConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DhcpSetConfig(ctx context.Context, body DhcpSetConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpStatus request
	DhcpStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsConfig request with any body
	DnsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DnsConfig(ctx context.Context, body DnsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsInfo request
	DnsInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringAddURL request with any body
	FilteringAddURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringAddURL(ctx context.Context, body FilteringAddURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringCheckHost request
	FilteringCheckHost(ctx context.Context, params *FilteringCheckHostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringConfig request with any body
	FilteringConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringConfig(ctx context.Context, body FilteringConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringRefresh request with any body
	FilteringRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringRefresh(ctx context.Context, body FilteringRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringRemoveURL request with any body
	FilteringRemoveURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringRemoveURL(ctx context.Context, body FilteringRemoveURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringSetRules request with any body
	FilteringSetRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringSetRules(ctx context.Context, body FilteringSetRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringSetURL request with any body
	FilteringSetURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringSetURL(ctx context.Context, body FilteringSetURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringStatus request
	FilteringStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeLanguage request with any body
	ChangeLanguageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeLanguage(ctx context.Context, body ChangeLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CurrentLanguage request
	CurrentLanguage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallCheckConfig request with any body
	InstallCheckConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallCheckConfig(ctx context.Context, body InstallCheckConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallCheckConfigBeta request with any body
	InstallCheckConfigBetaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallCheckConfigBeta(ctx context.Context, body InstallCheckConfigBetaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallConfigure request with any body
	InstallConfigureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallConfigure(ctx context.Context, body InstallConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallConfigureBeta request with any body
	InstallConfigureBetaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallConfigureBeta(ctx context.Context, body InstallConfigureBetaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallGetAddresses request
	InstallGetAddresses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallGetAddressesBeta request
	InstallGetAddressesBeta(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParentalDisable request
	ParentalDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParentalEnable request
	ParentalEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParentalStatus request
	ParentalStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfile request
	GetProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryLog request
	QueryLog(ctx context.Context, params *QueryLogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QuerylogClear request
	QuerylogClear(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryLogConfig request with any body
	QueryLogConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryLogConfig(ctx context.Context, body QueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryLogInfo request
	QueryLogInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RewriteAdd request with any body
	RewriteAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RewriteAdd(ctx context.Context, body RewriteAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RewriteDelete request with any body
	RewriteDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RewriteDelete(ctx context.Context, body RewriteDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RewriteList request
	RewriteList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafebrowsingDisable request
	SafebrowsingDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafebrowsingEnable request
	SafebrowsingEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafebrowsingStatus request
	SafebrowsingStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafesearchDisable request
	SafesearchDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafesearchEnable request
	SafesearchEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafesearchStatus request
	SafesearchStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Stats request
	Stats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatsConfig request with any body
	StatsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StatsConfig(ctx context.Context, body StatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatsInfo request
	StatsInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatsReset request
	StatsReset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Status request
	Status(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestUpstreamDNS request with any body
	TestUpstreamDNSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestUpstreamDNS(ctx context.Context, body TestUpstreamDNSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TlsConfigure request with any body
	TlsConfigureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TlsConfigure(ctx context.Context, body TlsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TlsStatus request
	TlsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TlsValidate request with any body
	TlsValidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TlsValidate(ctx context.Context, body TlsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BeginUpdate request
	BeginUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionJson request with any body
	GetVersionJsonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetVersionJson(ctx context.Context, body GetVersionJsonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *AdguardHomeClient) AccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccessListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) AccessSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccessSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) AccessSet(ctx context.Context, body AccessSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccessSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) MobileConfigDoH(ctx context.Context, params *MobileConfigDoHParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMobileConfigDoHRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) MobileConfigDoT(ctx context.Context, params *MobileConfigDoTParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMobileConfigDoTRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesAvailableServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesAvailableServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesSet(ctx context.Context, body BlockedServicesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) CacheClear(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheClearRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsAddRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsAdd(ctx context.Context, body ClientsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsAddRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsDelete(ctx context.Context, body ClientsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsFind(ctx context.Context, params *ClientsFindParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsFindRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsUpdate(ctx context.Context, body ClientsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpAddStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpAddStaticLeaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpAddStaticLease(ctx context.Context, body DhcpAddStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpAddStaticLeaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) CheckActiveDhcpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckActiveDhcpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) CheckActiveDhcp(ctx context.Context, body CheckActiveDhcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckActiveDhcpRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpInterfaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpInterfacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpRemoveStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpRemoveStaticLeaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpRemoveStaticLease(ctx context.Context, body DhcpRemoveStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpRemoveStaticLeaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpReset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpResetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpResetLeases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpResetLeasesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpSetConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpSetConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpSetConfig(ctx context.Context, body DhcpSetConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpSetConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DnsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DnsConfig(ctx context.Context, body DnsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DnsInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringAddURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringAddURLRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringAddURL(ctx context.Context, body FilteringAddURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringAddURLRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringCheckHost(ctx context.Context, params *FilteringCheckHostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringCheckHostRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringConfig(ctx context.Context, body FilteringConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringRefreshRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringRefresh(ctx context.Context, body FilteringRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringRefreshRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringRemoveURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringRemoveURLRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringRemoveURL(ctx context.Context, body FilteringRemoveURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringRemoveURLRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringSetRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringSetRulesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringSetRules(ctx context.Context, body FilteringSetRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringSetRulesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringSetURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringSetURLRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringSetURL(ctx context.Context, body FilteringSetURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringSetURLRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ChangeLanguageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeLanguageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ChangeLanguage(ctx context.Context, body ChangeLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeLanguageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) CurrentLanguage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentLanguageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallCheckConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallCheckConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallCheckConfig(ctx context.Context, body InstallCheckConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallCheckConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallCheckConfigBetaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallCheckConfigBetaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallCheckConfigBeta(ctx context.Context, body InstallCheckConfigBetaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallCheckConfigBetaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallConfigureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallConfigureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallConfigure(ctx context.Context, body InstallConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallConfigureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallConfigureBetaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallConfigureBetaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallConfigureBeta(ctx context.Context, body InstallConfigureBetaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallConfigureBetaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallGetAddresses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallGetAddressesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallGetAddressesBeta(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallGetAddressesBetaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ParentalDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParentalDisableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ParentalEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParentalEnableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ParentalStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParentalStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) GetProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QueryLog(ctx context.Context, params *QueryLogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryLogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QuerylogClear(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuerylogClearRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QueryLogConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryLogConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QueryLogConfig(ctx context.Context, body QueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryLogConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QueryLogInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryLogInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteAddRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteAdd(ctx context.Context, body RewriteAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteAddRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteDelete(ctx context.Context, body RewriteDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafebrowsingDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafebrowsingDisableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafebrowsingEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafebrowsingEnableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafebrowsingStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafebrowsingStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafesearchDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafesearchDisableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafesearchEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafesearchEnableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafesearchStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafesearchStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) Stats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) StatsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) StatsConfig(ctx context.Context, body StatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) StatsInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) StatsReset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsResetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) Status(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TestUpstreamDNSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestUpstreamDNSRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TestUpstreamDNS(ctx context.Context, body TestUpstreamDNSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestUpstreamDNSRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsConfigureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsConfigureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsConfigure(ctx context.Context, body TlsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsConfigureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsValidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsValidateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsValidate(ctx context.Context, body TlsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsValidateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BeginUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBeginUpdateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) GetVersionJsonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionJsonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) GetVersionJson(ctx context.Context, body GetVersionJsonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionJsonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAccessListRequest generates requests for AccessList
func NewAccessListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccessSetRequest calls the generic AccessSet builder with application/json body
func NewAccessSetRequest(server string, body AccessSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccessSetRequestWithBody(server, "application/json", bodyReader)
}

// NewAccessSetRequestWithBody generates requests for AccessSet with any type of body
func NewAccessSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access/set")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMobileConfigDoHRequest generates requests for MobileConfigDoH
func NewMobileConfigDoHRequest(server string, params *MobileConfigDoHParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apple/doh.mobileconfig")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, params.Host); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.ClientId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMobileConfigDoTRequest generates requests for MobileConfigDoT
func NewMobileConfigDoTRequest(server string, params *MobileConfigDoTParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apple/dot.mobileconfig")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, params.Host); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.ClientId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedServicesAllRequest generates requests for BlockedServicesAll
func NewBlockedServicesAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedServicesListRequest generates requests for BlockedServicesList
func NewBlockedServicesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedServicesAvailableServicesRequest generates requests for BlockedServicesAvailableServices
func NewBlockedServicesAvailableServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedServicesSetRequest calls the generic BlockedServicesSet builder with application/json body
func NewBlockedServicesSetRequest(server string, body BlockedServicesSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBlockedServicesSetRequestWithBody(server, "application/json", bodyReader)
}

// NewBlockedServicesSetRequestWithBody generates requests for BlockedServicesSet with any type of body
func NewBlockedServicesSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/set")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCacheClearRequest generates requests for CacheClear
func NewCacheClearRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cache_clear")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClientsStatusRequest generates requests for ClientsStatus
func NewClientsStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClientsAddRequest calls the generic ClientsAdd builder with application/json body
func NewClientsAddRequest(server string, body ClientsAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClientsAddRequestWithBody(server, "application/json", bodyReader)
}

// NewClientsAddRequestWithBody generates requests for ClientsAdd with any type of body
func NewClientsAddRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClientsDeleteRequest calls the generic ClientsDelete builder with application/json body
func NewClientsDeleteRequest(server string, body ClientsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClientsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewClientsDeleteRequestWithBody generates requests for ClientsDelete with any type of body
func NewClientsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClientsFindRequest generates requests for ClientsFind
func NewClientsFindRequest(server string, params *ClientsFindParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/find")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Ip0 != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip0", runtime.ParamLocationQuery, *params.Ip0); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClientsUpdateRequest calls the generic ClientsUpdate builder with application/json body
func NewClientsUpdateRequest(server string, body ClientsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClientsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewClientsUpdateRequestWithBody generates requests for ClientsUpdate with any type of body
func NewClientsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDhcpAddStaticLeaseRequest calls the generic DhcpAddStaticLease builder with application/json body
func NewDhcpAddStaticLeaseRequest(server string, body DhcpAddStaticLeaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDhcpAddStaticLeaseRequestWithBody(server, "application/json", bodyReader)
}

// NewDhcpAddStaticLeaseRequestWithBody generates requests for DhcpAddStaticLease with any type of body
func NewDhcpAddStaticLeaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/add_static_lease")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckActiveDhcpRequest calls the generic CheckActiveDhcp builder with application/json body
func NewCheckActiveDhcpRequest(server string, body CheckActiveDhcpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckActiveDhcpRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckActiveDhcpRequestWithBody generates requests for CheckActiveDhcp with any type of body
func NewCheckActiveDhcpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/find_active_dhcp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDhcpInterfacesRequest generates requests for DhcpInterfaces
func NewDhcpInterfacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDhcpRemoveStaticLeaseRequest calls the generic DhcpRemoveStaticLease builder with application/json body
func NewDhcpRemoveStaticLeaseRequest(server string, body DhcpRemoveStaticLeaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDhcpRemoveStaticLeaseRequestWithBody(server, "application/json", bodyReader)
}

// NewDhcpRemoveStaticLeaseRequestWithBody generates requests for DhcpRemoveStaticLease with any type of body
func NewDhcpRemoveStaticLeaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/remove_static_lease")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDhcpResetRequest generates requests for DhcpReset
func NewDhcpResetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDhcpResetLeasesRequest generates requests for DhcpResetLeases
func NewDhcpResetLeasesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/reset_leases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDhcpSetConfigRequest calls the generic DhcpSetConfig builder with application/json body
func NewDhcpSetConfigRequest(server string, body DhcpSetConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDhcpSetConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewDhcpSetConfigRequestWithBody generates requests for DhcpSetConfig with any type of body
func NewDhcpSetConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/set_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDhcpStatusRequest generates requests for DhcpStatus
func NewDhcpStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDnsConfigRequest calls the generic DnsConfig builder with application/json body
func NewDnsConfigRequest(server string, body DnsConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDnsConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewDnsConfigRequestWithBody generates requests for DnsConfig with any type of body
func NewDnsConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dns_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDnsInfoRequest generates requests for DnsInfo
func NewDnsInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dns_info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFilteringAddURLRequest calls the generic FilteringAddURL builder with application/json body
func NewFilteringAddURLRequest(server string, body FilteringAddURLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringAddURLRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringAddURLRequestWithBody generates requests for FilteringAddURL with any type of body
func NewFilteringAddURLRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/add_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringCheckHostRequest generates requests for FilteringCheckHost
func NewFilteringCheckHostRequest(server string, params *FilteringCheckHostParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/check_host")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFilteringConfigRequest calls the generic FilteringConfig builder with application/json body
func NewFilteringConfigRequest(server string, body FilteringConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringConfigRequestWithBody generates requests for FilteringConfig with any type of body
func NewFilteringConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringRefreshRequest calls the generic FilteringRefresh builder with application/json body
func NewFilteringRefreshRequest(server string, body FilteringRefreshJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringRefreshRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringRefreshRequestWithBody generates requests for FilteringRefresh with any type of body
func NewFilteringRefreshRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringRemoveURLRequest calls the generic FilteringRemoveURL builder with application/json body
func NewFilteringRemoveURLRequest(server string, body FilteringRemoveURLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringRemoveURLRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringRemoveURLRequestWithBody generates requests for FilteringRemoveURL with any type of body
func NewFilteringRemoveURLRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/remove_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringSetRulesRequest calls the generic FilteringSetRules builder with application/json body
func NewFilteringSetRulesRequest(server string, body FilteringSetRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringSetRulesRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringSetRulesRequestWithBody generates requests for FilteringSetRules with any type of body
func NewFilteringSetRulesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/set_rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringSetURLRequest calls the generic FilteringSetURL builder with application/json body
func NewFilteringSetURLRequest(server string, body FilteringSetURLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringSetURLRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringSetURLRequestWithBody generates requests for FilteringSetURL with any type of body
func NewFilteringSetURLRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/set_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringStatusRequest generates requests for FilteringStatus
func NewFilteringStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangeLanguageRequest calls the generic ChangeLanguage builder with application/json body
func NewChangeLanguageRequest(server string, body ChangeLanguageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeLanguageRequestWithBody(server, "application/json", bodyReader)
}

// NewChangeLanguageRequestWithBody generates requests for ChangeLanguage with any type of body
func NewChangeLanguageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/i18n/change_language")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCurrentLanguageRequest generates requests for CurrentLanguage
func NewCurrentLanguageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/i18n/current_language")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallCheckConfigRequest calls the generic InstallCheckConfig builder with application/json body
func NewInstallCheckConfigRequest(server string, body InstallCheckConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallCheckConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewInstallCheckConfigRequestWithBody generates requests for InstallCheckConfig with any type of body
func NewInstallCheckConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/install/check_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstallCheckConfigBetaRequest calls the generic InstallCheckConfigBeta builder with application/json body
func NewInstallCheckConfigBetaRequest(server string, body InstallCheckConfigBetaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallCheckConfigBetaRequestWithBody(server, "application/json", bodyReader)
}

// NewInstallCheckConfigBetaRequestWithBody generates requests for InstallCheckConfigBeta with any type of body
func NewInstallCheckConfigBetaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/install/check_config_beta")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstallConfigureRequest calls the generic InstallConfigure builder with application/json body
func NewInstallConfigureRequest(server string, body InstallConfigureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallConfigureRequestWithBody(server, "application/json", bodyReader)
}

// NewInstallConfigureRequestWithBody generates requests for InstallConfigure with any type of body
func NewInstallConfigureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/install/configure")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstallConfigureBetaRequest calls the generic InstallConfigureBeta builder with application/json body
func NewInstallConfigureBetaRequest(server string, body InstallConfigureBetaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallConfigureBetaRequestWithBody(server, "application/json", bodyReader)
}

// NewInstallConfigureBetaRequestWithBody generates requests for InstallConfigureBeta with any type of body
func NewInstallConfigureBetaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/install/configure_beta")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstallGetAddressesRequest generates requests for InstallGetAddresses
func NewInstallGetAddressesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/install/get_addresses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallGetAddressesBetaRequest generates requests for InstallGetAddressesBeta
func NewInstallGetAddressesBetaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/install/get_addresses_beta")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewParentalDisableRequest generates requests for ParentalDisable
func NewParentalDisableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parental/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewParentalEnableRequest generates requests for ParentalEnable
func NewParentalEnableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parental/enable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewParentalStatusRequest generates requests for ParentalStatus
func NewParentalStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parental/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProfileRequest generates requests for GetProfile
func NewGetProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryLogRequest generates requests for QueryLog
func NewQueryLogRequest(server string, params *QueryLogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OlderThan != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "older_than", runtime.ParamLocationQuery, *params.OlderThan); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ResponseStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_status", runtime.ParamLocationQuery, *params.ResponseStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQuerylogClearRequest generates requests for QuerylogClear
func NewQuerylogClearRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog_clear")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryLogConfigRequest calls the generic QueryLogConfig builder with application/json body
func NewQueryLogConfigRequest(server string, body QueryLogConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryLogConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryLogConfigRequestWithBody generates requests for QueryLogConfig with any type of body
func NewQueryLogConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryLogInfoRequest generates requests for QueryLogInfo
func NewQueryLogInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog_info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRewriteAddRequest calls the generic RewriteAdd builder with application/json body
func NewRewriteAddRequest(server string, body RewriteAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRewriteAddRequestWithBody(server, "application/json", bodyReader)
}

// NewRewriteAddRequestWithBody generates requests for RewriteAdd with any type of body
func NewRewriteAddRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rewrite/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRewriteDeleteRequest calls the generic RewriteDelete builder with application/json body
func NewRewriteDeleteRequest(server string, body RewriteDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRewriteDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewRewriteDeleteRequestWithBody generates requests for RewriteDelete with any type of body
func NewRewriteDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rewrite/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRewriteListRequest generates requests for RewriteList
func NewRewriteListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rewrite/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafebrowsingDisableRequest generates requests for SafebrowsingDisable
func NewSafebrowsingDisableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safebrowsing/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafebrowsingEnableRequest generates requests for SafebrowsingEnable
func NewSafebrowsingEnableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safebrowsing/enable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafebrowsingStatusRequest generates requests for SafebrowsingStatus
func NewSafebrowsingStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safebrowsing/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafesearchDisableRequest generates requests for SafesearchDisable
func NewSafesearchDisableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safesearch/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafesearchEnableRequest generates requests for SafesearchEnable
func NewSafesearchEnableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safesearch/enable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafesearchStatusRequest generates requests for SafesearchStatus
func NewSafesearchStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safesearch/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatsRequest generates requests for Stats
func NewStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatsConfigRequest calls the generic StatsConfig builder with application/json body
func NewStatsConfigRequest(server string, body StatsConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStatsConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewStatsConfigRequestWithBody generates requests for StatsConfig with any type of body
func NewStatsConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStatsInfoRequest generates requests for StatsInfo
func NewStatsInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats_info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatsResetRequest generates requests for StatsReset
func NewStatsResetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats_reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatusRequest generates requests for Status
func NewStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestUpstreamDNSRequest calls the generic TestUpstreamDNS builder with application/json body
func NewTestUpstreamDNSRequest(server string, body TestUpstreamDNSJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestUpstreamDNSRequestWithBody(server, "application/json", bodyReader)
}

// NewTestUpstreamDNSRequestWithBody generates requests for TestUpstreamDNS with any type of body
func NewTestUpstreamDNSRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/test_upstream_dns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTlsConfigureRequest calls the generic TlsConfigure builder with application/json body
func NewTlsConfigureRequest(server string, body TlsConfigureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTlsConfigureRequestWithBody(server, "application/json", bodyReader)
}

// NewTlsConfigureRequestWithBody generates requests for TlsConfigure with any type of body
func NewTlsConfigureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tls/configure")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTlsStatusRequest generates requests for TlsStatus
func NewTlsStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tls/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTlsValidateRequest calls the generic TlsValidate builder with application/json body
func NewTlsValidateRequest(server string, body TlsValidateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTlsValidateRequestWithBody(server, "application/json", bodyReader)
}

// NewTlsValidateRequestWithBody generates requests for TlsValidate with any type of body
func NewTlsValidateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tls/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBeginUpdateRequest generates requests for BeginUpdate
func NewBeginUpdateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionJsonRequest calls the generic GetVersionJson builder with application/json body
func NewGetVersionJsonRequest(server string, body GetVersionJsonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetVersionJsonRequestWithBody(server, "application/json", bodyReader)
}

// NewGetVersionJsonRequestWithBody generates requests for GetVersionJson with any type of body
func NewGetVersionJsonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *AdguardHomeClient) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *AdguardHomeClient) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AccessList request
	AccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccessListResponse, error)

	// AccessSet request with any body
	AccessSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccessSetResponse, error)

	AccessSetWithResponse(ctx context.Context, body AccessSetJSONRequestBody, reqEditors ...RequestEditorFn) (*AccessSetResponse, error)

	// MobileConfigDoH request
	MobileConfigDoHWithResponse(ctx context.Context, params *MobileConfigDoHParams, reqEditors ...RequestEditorFn) (*MobileConfigDoHResponse, error)

	// MobileConfigDoT request
	MobileConfigDoTWithResponse(ctx context.Context, params *MobileConfigDoTParams, reqEditors ...RequestEditorFn) (*MobileConfigDoTResponse, error)

	// BlockedServicesAll request
	BlockedServicesAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesAllResponse, error)

	// BlockedServicesList request
	BlockedServicesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesListResponse, error)

	// BlockedServicesAvailableServices request
	BlockedServicesAvailableServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesAvailableServicesResponse, error)

	// BlockedServicesSet request with any body
	BlockedServicesSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockedServicesSetResponse, error)

	BlockedServicesSetWithResponse(ctx context.Context, body BlockedServicesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockedServicesSetResponse, error)

	// CacheClear request
	CacheClearWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CacheClearResponse, error)

	// ClientsStatus request
	ClientsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClientsStatusResponse, error)

	// ClientsAdd request with any body
	ClientsAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsAddResponse, error)

	ClientsAddWithResponse(ctx context.Context, body ClientsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsAddResponse, error)

	// ClientsDelete request with any body
	ClientsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsDeleteResponse, error)

	ClientsDeleteWithResponse(ctx context.Context, body ClientsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsDeleteResponse, error)

	// ClientsFind request
	ClientsFindWithResponse(ctx context.Context, params *ClientsFindParams, reqEditors ...RequestEditorFn) (*ClientsFindResponse, error)

	// ClientsUpdate request with any body
	ClientsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsUpdateResponse, error)

	ClientsUpdateWithResponse(ctx context.Context, body ClientsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsUpdateResponse, error)

	// DhcpAddStaticLease request with any body
	DhcpAddStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpAddStaticLeaseResponse, error)

	DhcpAddStaticLeaseWithResponse(ctx context.Context, body DhcpAddStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpAddStaticLeaseResponse, error)

	// CheckActiveDhcp request with any body
	CheckActiveDhcpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckActiveDhcpResponse, error)

	CheckActiveDhcpWithResponse(ctx context.Context, body CheckActiveDhcpJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckActiveDhcpResponse, error)

	// DhcpInterfaces request
	DhcpInterfacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpInterfacesResponse, error)

	// DhcpRemoveStaticLease request with any body
	DhcpRemoveStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpRemoveStaticLeaseResponse, error)

	DhcpRemoveStaticLeaseWithResponse(ctx context.Context, body DhcpRemoveStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpRemoveStaticLeaseResponse, error)

	// DhcpReset request
	DhcpResetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpResetResponse, error)

	// DhcpResetLeases request
	DhcpResetLeasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpResetLeasesResponse, error)

	// DhcpSetConfig request with any body
	DhcpSetConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpSetConfigResponse, error)

	DhcpSetConfigWithResponse(ctx context.Context, body DhcpSetConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpSetConfigResponse, error)

	// DhcpStatus request
	DhcpStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpStatusResponse, error)

	// DnsConfig request with any body
	DnsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsConfigResponse, error)

	DnsConfigWithResponse(ctx context.Context, body DnsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsConfigResponse, error)

	// DnsInfo request
	DnsInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DnsInfoResponse, error)

	// FilteringAddURL request with any body
	FilteringAddURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringAddURLResponse, error)

	FilteringAddURLWithResponse(ctx context.Context, body FilteringAddURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringAddURLResponse, error)

	// FilteringCheckHost request
	FilteringCheckHostWithResponse(ctx context.Context, params *FilteringCheckHostParams, reqEditors ...RequestEditorFn) (*FilteringCheckHostResponse, error)

	// FilteringConfig request with any body
	FilteringConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringConfigResponse, error)

	FilteringConfigWithResponse(ctx context.Context, body FilteringConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringConfigResponse, error)

	// FilteringRefresh request with any body
	FilteringRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringRefreshResponse, error)

	FilteringRefreshWithResponse(ctx context.Context, body FilteringRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringRefreshResponse, error)

	// FilteringRemoveURL request with any body
	FilteringRemoveURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringRemoveURLResponse, error)

	FilteringRemoveURLWithResponse(ctx context.Context, body FilteringRemoveURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringRemoveURLResponse, error)

	// FilteringSetRules request with any body
	FilteringSetRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringSetRulesResponse, error)

	FilteringSetRulesWithResponse(ctx context.Context, body FilteringSetRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringSetRulesResponse, error)

	// FilteringSetURL request with any body
	FilteringSetURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringSetURLResponse, error)

	FilteringSetURLWithResponse(ctx context.Context, body FilteringSetURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringSetURLResponse, error)

	// FilteringStatus request
	FilteringStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FilteringStatusResponse, error)

	// ChangeLanguage request with any body
	ChangeLanguageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeLanguageResponse, error)

	ChangeLanguageWithResponse(ctx context.Context, body ChangeLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeLanguageResponse, error)

	// CurrentLanguage request
	CurrentLanguageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentLanguageResponse, error)

	// InstallCheckConfig request with any body
	InstallCheckConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallCheckConfigResponse, error)

	InstallCheckConfigWithResponse(ctx context.Context, body InstallCheckConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallCheckConfigResponse, error)

	// InstallCheckConfigBeta request with any body
	InstallCheckConfigBetaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallCheckConfigBetaResponse, error)

	InstallCheckConfigBetaWithResponse(ctx context.Context, body InstallCheckConfigBetaJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallCheckConfigBetaResponse, error)

	// InstallConfigure request with any body
	InstallConfigureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallConfigureResponse, error)

	InstallConfigureWithResponse(ctx context.Context, body InstallConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallConfigureResponse, error)

	// InstallConfigureBeta request with any body
	InstallConfigureBetaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallConfigureBetaResponse, error)

	InstallConfigureBetaWithResponse(ctx context.Context, body InstallConfigureBetaJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallConfigureBetaResponse, error)

	// InstallGetAddresses request
	InstallGetAddressesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstallGetAddressesResponse, error)

	// InstallGetAddressesBeta request
	InstallGetAddressesBetaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstallGetAddressesBetaResponse, error)

	// Login request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// Logout request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// ParentalDisable request
	ParentalDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalDisableResponse, error)

	// ParentalEnable request
	ParentalEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalEnableResponse, error)

	// ParentalStatus request
	ParentalStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalStatusResponse, error)

	// GetProfile request
	GetProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProfileResponse, error)

	// QueryLog request
	QueryLogWithResponse(ctx context.Context, params *QueryLogParams, reqEditors ...RequestEditorFn) (*QueryLogResponse, error)

	// QuerylogClear request
	QuerylogClearWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QuerylogClearResponse, error)

	// QueryLogConfig request with any body
	QueryLogConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryLogConfigResponse, error)

	QueryLogConfigWithResponse(ctx context.Context, body QueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryLogConfigResponse, error)

	// QueryLogInfo request
	QueryLogInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueryLogInfoResponse, error)

	// RewriteAdd request with any body
	RewriteAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteAddResponse, error)

	RewriteAddWithResponse(ctx context.Context, body RewriteAddJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteAddResponse, error)

	// RewriteDelete request with any body
	RewriteDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteDeleteResponse, error)

	RewriteDeleteWithResponse(ctx context.Context, body RewriteDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteDeleteResponse, error)

	// RewriteList request
	RewriteListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RewriteListResponse, error)

	// SafebrowsingDisable request
	SafebrowsingDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingDisableResponse, error)

	// SafebrowsingEnable request
	SafebrowsingEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingEnableResponse, error)

	// SafebrowsingStatus request
	SafebrowsingStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingStatusResponse, error)

	// SafesearchDisable request
	SafesearchDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchDisableResponse, error)

	// SafesearchEnable request
	SafesearchEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchEnableResponse, error)

	// SafesearchStatus request
	SafesearchStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchStatusResponse, error)

	// Stats request
	StatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsResponse, error)

	// StatsConfig request with any body
	StatsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StatsConfigResponse, error)

	StatsConfigWithResponse(ctx context.Context, body StatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*StatsConfigResponse, error)

	// StatsInfo request
	StatsInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsInfoResponse, error)

	// StatsReset request
	StatsResetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsResetResponse, error)

	// Status request
	StatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusResponse, error)

	// TestUpstreamDNS request with any body
	TestUpstreamDNSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestUpstreamDNSResponse, error)

	TestUpstreamDNSWithResponse(ctx context.Context, body TestUpstreamDNSJSONRequestBody, reqEditors ...RequestEditorFn) (*TestUpstreamDNSResponse, error)

	// TlsConfigure request with any body
	TlsConfigureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TlsConfigureResponse, error)

	TlsConfigureWithResponse(ctx context.Context, body TlsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*TlsConfigureResponse, error)

	// TlsStatus request
	TlsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TlsStatusResponse, error)

	// TlsValidate request with any body
	TlsValidateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TlsValidateResponse, error)

	TlsValidateWithResponse(ctx context.Context, body TlsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*TlsValidateResponse, error)

	// BeginUpdate request
	BeginUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BeginUpdateResponse, error)

	// GetVersionJson request with any body
	GetVersionJsonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVersionJsonResponse, error)

	GetVersionJsonWithResponse(ctx context.Context, body GetVersionJsonJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVersionJsonResponse, error)
}

type AccessListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessListResponseType
}

// Status returns HTTPResponse.Status
func (r AccessListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccessListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccessSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AccessSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccessSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MobileConfigDoHResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r MobileConfigDoHResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MobileConfigDoHResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MobileConfigDoTResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r MobileConfigDoTResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MobileConfigDoTResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedServicesAll
}

// Status returns HTTPResponse.Status
func (r BlockedServicesAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedServicesArray
}

// Status returns HTTPResponse.Status
func (r BlockedServicesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesAvailableServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedServicesArray
}

// Status returns HTTPResponse.Status
func (r BlockedServicesAvailableServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesAvailableServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BlockedServicesSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheClearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CacheClearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheClearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Clients
}

// Status returns HTTPResponse.Status
func (r ClientsStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClientsAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClientsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsFindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientsFindResponseType
}

// Status returns HTTPResponse.Status
func (r ClientsFindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsFindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClientsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpAddStaticLeaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpAddStaticLeaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpAddStaticLeaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckActiveDhcpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DhcpSearchResult
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r CheckActiveDhcpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckActiveDhcpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetInterfaces
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpRemoveStaticLeaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpRemoveStaticLeaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpRemoveStaticLeaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpResetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpResetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpResetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpResetLeasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpResetLeasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpResetLeasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpSetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpSetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpSetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DhcpStatus
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DnsConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		BlockingIpv4 *string                `json:"blocking_ipv4,omitempty"`
		BlockingIpv6 *string                `json:"blocking_ipv6,omitempty"`
		BlockingMode *DNSConfigBlockingMode `json:"blocking_mode,omitempty"`

		// BootstrapDns Bootstrap servers, port is optional after colon.  Empty value will reset it to default values.
		BootstrapDns             *[]string `json:"bootstrap_dns,omitempty"`
		CacheOptimistic          *bool     `json:"cache_optimistic,omitempty"`
		CacheSize                *int      `json:"cache_size,omitempty"`
		CacheTtlMax              *int      `json:"cache_ttl_max,omitempty"`
		CacheTtlMin              *int      `json:"cache_ttl_min,omitempty"`
		DefaultLocalPtrUpstreams *[]string `json:"default_local_ptr_upstreams,omitempty"`
		DhcpAvailable            *bool     `json:"dhcp_available,omitempty"`
		DisableIpv6              *bool     `json:"disable_ipv6,omitempty"`
		DnssecEnabled            *bool     `json:"dnssec_enabled,omitempty"`
		EdnsCsEnabled            *bool     `json:"edns_cs_enabled,omitempty"`

		// LocalPtrUpstreams Upstream servers, port is optional after colon.  Empty value will reset it to default values.
		LocalPtrUpstreams *[]string `json:"local_ptr_upstreams,omitempty"`
		ProtectionEnabled *bool     `json:"protection_enabled,omitempty"`
		Ratelimit         *int      `json:"ratelimit,omitempty"`
		ResolveClients    *bool     `json:"resolve_clients,omitempty"`

		// UpstreamDns Upstream servers, port is optional after colon.  Empty value will reset it to default values.
		UpstreamDns            *[]string    `json:"upstream_dns,omitempty"`
		UpstreamDnsFile        *string      `json:"upstream_dns_file,omitempty"`
		UpstreamMode           *interface{} `json:"upstream_mode,omitempty"`
		UsePrivatePtrResolvers *bool        `json:"use_private_ptr_resolvers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DnsInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringAddURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringAddURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringAddURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringCheckHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterCheckHostResponse
}

// Status returns HTTPResponse.Status
func (r FilteringCheckHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringCheckHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterRefreshResponse
}

// Status returns HTTPResponse.Status
func (r FilteringRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringRemoveURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringRemoveURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringRemoveURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringSetRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringSetRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringSetRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringSetURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringSetURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringSetURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterStatus
}

// Status returns HTTPResponse.Status
func (r FilteringStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeLanguageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ChangeLanguageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeLanguageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentLanguageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LanguageSettings
}

// Status returns HTTPResponse.Status
func (r CurrentLanguageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentLanguageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallCheckConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckConfigResponse
}

// Status returns HTTPResponse.Status
func (r InstallCheckConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallCheckConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallCheckConfigBetaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckConfigResponse
}

// Status returns HTTPResponse.Status
func (r InstallCheckConfigBetaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallCheckConfigBetaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallConfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallConfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallConfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallConfigureBetaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallConfigureBetaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallConfigureBetaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallGetAddressesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddressesInfo
}

// Status returns HTTPResponse.Status
func (r InstallGetAddressesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallGetAddressesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallGetAddressesBetaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddressesInfoBeta
}

// Status returns HTTPResponse.Status
func (r InstallGetAddressesBetaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallGetAddressesBetaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParentalDisableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ParentalDisableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParentalDisableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParentalEnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ParentalEnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParentalEnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParentalStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Enable      *bool `json:"enable,omitempty"`
		Sensitivity *int  `json:"sensitivity,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ParentalStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParentalStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileInfo
}

// Status returns HTTPResponse.Status
func (r GetProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryLog
}

// Status returns HTTPResponse.Status
func (r QueryLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QuerylogClearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QuerylogClearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QuerylogClearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryLogConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QueryLogConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryLogConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryLogInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryLogConfig
}

// Status returns HTTPResponse.Status
func (r QueryLogInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryLogInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RewriteAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RewriteAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RewriteAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RewriteDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RewriteDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RewriteDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RewriteListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RewriteList
}

// Status returns HTTPResponse.Status
func (r RewriteListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RewriteListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafebrowsingDisableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SafebrowsingDisableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafebrowsingDisableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafebrowsingEnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SafebrowsingEnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafebrowsingEnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafebrowsingStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Enabled *bool `json:"enabled,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SafebrowsingStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafebrowsingStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafesearchDisableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SafesearchDisableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafesearchDisableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafesearchEnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SafesearchEnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafesearchEnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafesearchStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Enabled *bool `json:"enabled,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SafesearchStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafesearchStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stats
}

// Status returns HTTPResponse.Status
func (r StatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatsConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsConfig
}

// Status returns HTTPResponse.Status
func (r StatsInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsResetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatsResetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsResetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerStatus
}

// Status returns HTTPResponse.Status
func (r StatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestUpstreamDNSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpstreamsConfigResponse
}

// Status returns HTTPResponse.Status
func (r TestUpstreamDNSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestUpstreamDNSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TlsConfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TlsConfig
}

// Status returns HTTPResponse.Status
func (r TlsConfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TlsConfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TlsStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TlsConfig
}

// Status returns HTTPResponse.Status
func (r TlsStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TlsStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TlsValidateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TlsConfig
}

// Status returns HTTPResponse.Status
func (r TlsValidateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TlsValidateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BeginUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BeginUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BeginUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionJsonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionInfo
}

// Status returns HTTPResponse.Status
func (r GetVersionJsonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionJsonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AccessListWithResponse request returning *AccessListResponse
func (c *ClientWithResponses) AccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccessListResponse, error) {
	rsp, err := c.AccessList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccessListResponse(rsp)
}

// AccessSetWithBodyWithResponse request with arbitrary body returning *AccessSetResponse
func (c *ClientWithResponses) AccessSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccessSetResponse, error) {
	rsp, err := c.AccessSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccessSetResponse(rsp)
}

func (c *ClientWithResponses) AccessSetWithResponse(ctx context.Context, body AccessSetJSONRequestBody, reqEditors ...RequestEditorFn) (*AccessSetResponse, error) {
	rsp, err := c.AccessSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccessSetResponse(rsp)
}

// MobileConfigDoHWithResponse request returning *MobileConfigDoHResponse
func (c *ClientWithResponses) MobileConfigDoHWithResponse(ctx context.Context, params *MobileConfigDoHParams, reqEditors ...RequestEditorFn) (*MobileConfigDoHResponse, error) {
	rsp, err := c.MobileConfigDoH(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMobileConfigDoHResponse(rsp)
}

// MobileConfigDoTWithResponse request returning *MobileConfigDoTResponse
func (c *ClientWithResponses) MobileConfigDoTWithResponse(ctx context.Context, params *MobileConfigDoTParams, reqEditors ...RequestEditorFn) (*MobileConfigDoTResponse, error) {
	rsp, err := c.MobileConfigDoT(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMobileConfigDoTResponse(rsp)
}

// BlockedServicesAllWithResponse request returning *BlockedServicesAllResponse
func (c *ClientWithResponses) BlockedServicesAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesAllResponse, error) {
	rsp, err := c.BlockedServicesAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesAllResponse(rsp)
}

// BlockedServicesListWithResponse request returning *BlockedServicesListResponse
func (c *ClientWithResponses) BlockedServicesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesListResponse, error) {
	rsp, err := c.BlockedServicesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesListResponse(rsp)
}

// BlockedServicesAvailableServicesWithResponse request returning *BlockedServicesAvailableServicesResponse
func (c *ClientWithResponses) BlockedServicesAvailableServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesAvailableServicesResponse, error) {
	rsp, err := c.BlockedServicesAvailableServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesAvailableServicesResponse(rsp)
}

// BlockedServicesSetWithBodyWithResponse request with arbitrary body returning *BlockedServicesSetResponse
func (c *ClientWithResponses) BlockedServicesSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockedServicesSetResponse, error) {
	rsp, err := c.BlockedServicesSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesSetResponse(rsp)
}

func (c *ClientWithResponses) BlockedServicesSetWithResponse(ctx context.Context, body BlockedServicesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockedServicesSetResponse, error) {
	rsp, err := c.BlockedServicesSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesSetResponse(rsp)
}

// CacheClearWithResponse request returning *CacheClearResponse
func (c *ClientWithResponses) CacheClearWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CacheClearResponse, error) {
	rsp, err := c.CacheClear(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheClearResponse(rsp)
}

// ClientsStatusWithResponse request returning *ClientsStatusResponse
func (c *ClientWithResponses) ClientsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClientsStatusResponse, error) {
	rsp, err := c.ClientsStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsStatusResponse(rsp)
}

// ClientsAddWithBodyWithResponse request with arbitrary body returning *ClientsAddResponse
func (c *ClientWithResponses) ClientsAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsAddResponse, error) {
	rsp, err := c.ClientsAddWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsAddResponse(rsp)
}

func (c *ClientWithResponses) ClientsAddWithResponse(ctx context.Context, body ClientsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsAddResponse, error) {
	rsp, err := c.ClientsAdd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsAddResponse(rsp)
}

// ClientsDeleteWithBodyWithResponse request with arbitrary body returning *ClientsDeleteResponse
func (c *ClientWithResponses) ClientsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsDeleteResponse, error) {
	rsp, err := c.ClientsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsDeleteResponse(rsp)
}

func (c *ClientWithResponses) ClientsDeleteWithResponse(ctx context.Context, body ClientsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsDeleteResponse, error) {
	rsp, err := c.ClientsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsDeleteResponse(rsp)
}

// ClientsFindWithResponse request returning *ClientsFindResponse
func (c *ClientWithResponses) ClientsFindWithResponse(ctx context.Context, params *ClientsFindParams, reqEditors ...RequestEditorFn) (*ClientsFindResponse, error) {
	rsp, err := c.ClientsFind(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsFindResponse(rsp)
}

// ClientsUpdateWithBodyWithResponse request with arbitrary body returning *ClientsUpdateResponse
func (c *ClientWithResponses) ClientsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsUpdateResponse, error) {
	rsp, err := c.ClientsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ClientsUpdateWithResponse(ctx context.Context, body ClientsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsUpdateResponse, error) {
	rsp, err := c.ClientsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsUpdateResponse(rsp)
}

// DhcpAddStaticLeaseWithBodyWithResponse request with arbitrary body returning *DhcpAddStaticLeaseResponse
func (c *ClientWithResponses) DhcpAddStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpAddStaticLeaseResponse, error) {
	rsp, err := c.DhcpAddStaticLeaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpAddStaticLeaseResponse(rsp)
}

func (c *ClientWithResponses) DhcpAddStaticLeaseWithResponse(ctx context.Context, body DhcpAddStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpAddStaticLeaseResponse, error) {
	rsp, err := c.DhcpAddStaticLease(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpAddStaticLeaseResponse(rsp)
}

// CheckActiveDhcpWithBodyWithResponse request with arbitrary body returning *CheckActiveDhcpResponse
func (c *ClientWithResponses) CheckActiveDhcpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckActiveDhcpResponse, error) {
	rsp, err := c.CheckActiveDhcpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckActiveDhcpResponse(rsp)
}

func (c *ClientWithResponses) CheckActiveDhcpWithResponse(ctx context.Context, body CheckActiveDhcpJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckActiveDhcpResponse, error) {
	rsp, err := c.CheckActiveDhcp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckActiveDhcpResponse(rsp)
}

// DhcpInterfacesWithResponse request returning *DhcpInterfacesResponse
func (c *ClientWithResponses) DhcpInterfacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpInterfacesResponse, error) {
	rsp, err := c.DhcpInterfaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpInterfacesResponse(rsp)
}

// DhcpRemoveStaticLeaseWithBodyWithResponse request with arbitrary body returning *DhcpRemoveStaticLeaseResponse
func (c *ClientWithResponses) DhcpRemoveStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpRemoveStaticLeaseResponse, error) {
	rsp, err := c.DhcpRemoveStaticLeaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpRemoveStaticLeaseResponse(rsp)
}

func (c *ClientWithResponses) DhcpRemoveStaticLeaseWithResponse(ctx context.Context, body DhcpRemoveStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpRemoveStaticLeaseResponse, error) {
	rsp, err := c.DhcpRemoveStaticLease(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpRemoveStaticLeaseResponse(rsp)
}

// DhcpResetWithResponse request returning *DhcpResetResponse
func (c *ClientWithResponses) DhcpResetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpResetResponse, error) {
	rsp, err := c.DhcpReset(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpResetResponse(rsp)
}

// DhcpResetLeasesWithResponse request returning *DhcpResetLeasesResponse
func (c *ClientWithResponses) DhcpResetLeasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpResetLeasesResponse, error) {
	rsp, err := c.DhcpResetLeases(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpResetLeasesResponse(rsp)
}

// DhcpSetConfigWithBodyWithResponse request with arbitrary body returning *DhcpSetConfigResponse
func (c *ClientWithResponses) DhcpSetConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpSetConfigResponse, error) {
	rsp, err := c.DhcpSetConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpSetConfigResponse(rsp)
}

func (c *ClientWithResponses) DhcpSetConfigWithResponse(ctx context.Context, body DhcpSetConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpSetConfigResponse, error) {
	rsp, err := c.DhcpSetConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpSetConfigResponse(rsp)
}

// DhcpStatusWithResponse request returning *DhcpStatusResponse
func (c *ClientWithResponses) DhcpStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpStatusResponse, error) {
	rsp, err := c.DhcpStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpStatusResponse(rsp)
}

// DnsConfigWithBodyWithResponse request with arbitrary body returning *DnsConfigResponse
func (c *ClientWithResponses) DnsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsConfigResponse, error) {
	rsp, err := c.DnsConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsConfigResponse(rsp)
}

func (c *ClientWithResponses) DnsConfigWithResponse(ctx context.Context, body DnsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsConfigResponse, error) {
	rsp, err := c.DnsConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsConfigResponse(rsp)
}

// DnsInfoWithResponse request returning *DnsInfoResponse
func (c *ClientWithResponses) DnsInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DnsInfoResponse, error) {
	rsp, err := c.DnsInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsInfoResponse(rsp)
}

// FilteringAddURLWithBodyWithResponse request with arbitrary body returning *FilteringAddURLResponse
func (c *ClientWithResponses) FilteringAddURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringAddURLResponse, error) {
	rsp, err := c.FilteringAddURLWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringAddURLResponse(rsp)
}

func (c *ClientWithResponses) FilteringAddURLWithResponse(ctx context.Context, body FilteringAddURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringAddURLResponse, error) {
	rsp, err := c.FilteringAddURL(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringAddURLResponse(rsp)
}

// FilteringCheckHostWithResponse request returning *FilteringCheckHostResponse
func (c *ClientWithResponses) FilteringCheckHostWithResponse(ctx context.Context, params *FilteringCheckHostParams, reqEditors ...RequestEditorFn) (*FilteringCheckHostResponse, error) {
	rsp, err := c.FilteringCheckHost(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringCheckHostResponse(rsp)
}

// FilteringConfigWithBodyWithResponse request with arbitrary body returning *FilteringConfigResponse
func (c *ClientWithResponses) FilteringConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringConfigResponse, error) {
	rsp, err := c.FilteringConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringConfigResponse(rsp)
}

func (c *ClientWithResponses) FilteringConfigWithResponse(ctx context.Context, body FilteringConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringConfigResponse, error) {
	rsp, err := c.FilteringConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringConfigResponse(rsp)
}

// FilteringRefreshWithBodyWithResponse request with arbitrary body returning *FilteringRefreshResponse
func (c *ClientWithResponses) FilteringRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringRefreshResponse, error) {
	rsp, err := c.FilteringRefreshWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringRefreshResponse(rsp)
}

func (c *ClientWithResponses) FilteringRefreshWithResponse(ctx context.Context, body FilteringRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringRefreshResponse, error) {
	rsp, err := c.FilteringRefresh(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringRefreshResponse(rsp)
}

// FilteringRemoveURLWithBodyWithResponse request with arbitrary body returning *FilteringRemoveURLResponse
func (c *ClientWithResponses) FilteringRemoveURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringRemoveURLResponse, error) {
	rsp, err := c.FilteringRemoveURLWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringRemoveURLResponse(rsp)
}

func (c *ClientWithResponses) FilteringRemoveURLWithResponse(ctx context.Context, body FilteringRemoveURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringRemoveURLResponse, error) {
	rsp, err := c.FilteringRemoveURL(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringRemoveURLResponse(rsp)
}

// FilteringSetRulesWithBodyWithResponse request with arbitrary body returning *FilteringSetRulesResponse
func (c *ClientWithResponses) FilteringSetRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringSetRulesResponse, error) {
	rsp, err := c.FilteringSetRulesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringSetRulesResponse(rsp)
}

func (c *ClientWithResponses) FilteringSetRulesWithResponse(ctx context.Context, body FilteringSetRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringSetRulesResponse, error) {
	rsp, err := c.FilteringSetRules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringSetRulesResponse(rsp)
}

// FilteringSetURLWithBodyWithResponse request with arbitrary body returning *FilteringSetURLResponse
func (c *ClientWithResponses) FilteringSetURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringSetURLResponse, error) {
	rsp, err := c.FilteringSetURLWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringSetURLResponse(rsp)
}

func (c *ClientWithResponses) FilteringSetURLWithResponse(ctx context.Context, body FilteringSetURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringSetURLResponse, error) {
	rsp, err := c.FilteringSetURL(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringSetURLResponse(rsp)
}

// FilteringStatusWithResponse request returning *FilteringStatusResponse
func (c *ClientWithResponses) FilteringStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FilteringStatusResponse, error) {
	rsp, err := c.FilteringStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringStatusResponse(rsp)
}

// ChangeLanguageWithBodyWithResponse request with arbitrary body returning *ChangeLanguageResponse
func (c *ClientWithResponses) ChangeLanguageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeLanguageResponse, error) {
	rsp, err := c.ChangeLanguageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeLanguageResponse(rsp)
}

func (c *ClientWithResponses) ChangeLanguageWithResponse(ctx context.Context, body ChangeLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeLanguageResponse, error) {
	rsp, err := c.ChangeLanguage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeLanguageResponse(rsp)
}

// CurrentLanguageWithResponse request returning *CurrentLanguageResponse
func (c *ClientWithResponses) CurrentLanguageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentLanguageResponse, error) {
	rsp, err := c.CurrentLanguage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentLanguageResponse(rsp)
}

// InstallCheckConfigWithBodyWithResponse request with arbitrary body returning *InstallCheckConfigResponse
func (c *ClientWithResponses) InstallCheckConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallCheckConfigResponse, error) {
	rsp, err := c.InstallCheckConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallCheckConfigResponse(rsp)
}

func (c *ClientWithResponses) InstallCheckConfigWithResponse(ctx context.Context, body InstallCheckConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallCheckConfigResponse, error) {
	rsp, err := c.InstallCheckConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallCheckConfigResponse(rsp)
}

// InstallCheckConfigBetaWithBodyWithResponse request with arbitrary body returning *InstallCheckConfigBetaResponse
func (c *ClientWithResponses) InstallCheckConfigBetaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallCheckConfigBetaResponse, error) {
	rsp, err := c.InstallCheckConfigBetaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallCheckConfigBetaResponse(rsp)
}

func (c *ClientWithResponses) InstallCheckConfigBetaWithResponse(ctx context.Context, body InstallCheckConfigBetaJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallCheckConfigBetaResponse, error) {
	rsp, err := c.InstallCheckConfigBeta(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallCheckConfigBetaResponse(rsp)
}

// InstallConfigureWithBodyWithResponse request with arbitrary body returning *InstallConfigureResponse
func (c *ClientWithResponses) InstallConfigureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallConfigureResponse, error) {
	rsp, err := c.InstallConfigureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallConfigureResponse(rsp)
}

func (c *ClientWithResponses) InstallConfigureWithResponse(ctx context.Context, body InstallConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallConfigureResponse, error) {
	rsp, err := c.InstallConfigure(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallConfigureResponse(rsp)
}

// InstallConfigureBetaWithBodyWithResponse request with arbitrary body returning *InstallConfigureBetaResponse
func (c *ClientWithResponses) InstallConfigureBetaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallConfigureBetaResponse, error) {
	rsp, err := c.InstallConfigureBetaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallConfigureBetaResponse(rsp)
}

func (c *ClientWithResponses) InstallConfigureBetaWithResponse(ctx context.Context, body InstallConfigureBetaJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallConfigureBetaResponse, error) {
	rsp, err := c.InstallConfigureBeta(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallConfigureBetaResponse(rsp)
}

// InstallGetAddressesWithResponse request returning *InstallGetAddressesResponse
func (c *ClientWithResponses) InstallGetAddressesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstallGetAddressesResponse, error) {
	rsp, err := c.InstallGetAddresses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallGetAddressesResponse(rsp)
}

// InstallGetAddressesBetaWithResponse request returning *InstallGetAddressesBetaResponse
func (c *ClientWithResponses) InstallGetAddressesBetaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstallGetAddressesBetaResponse, error) {
	rsp, err := c.InstallGetAddressesBeta(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallGetAddressesBetaResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// ParentalDisableWithResponse request returning *ParentalDisableResponse
func (c *ClientWithResponses) ParentalDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalDisableResponse, error) {
	rsp, err := c.ParentalDisable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParentalDisableResponse(rsp)
}

// ParentalEnableWithResponse request returning *ParentalEnableResponse
func (c *ClientWithResponses) ParentalEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalEnableResponse, error) {
	rsp, err := c.ParentalEnable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParentalEnableResponse(rsp)
}

// ParentalStatusWithResponse request returning *ParentalStatusResponse
func (c *ClientWithResponses) ParentalStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalStatusResponse, error) {
	rsp, err := c.ParentalStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParentalStatusResponse(rsp)
}

// GetProfileWithResponse request returning *GetProfileResponse
func (c *ClientWithResponses) GetProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProfileResponse, error) {
	rsp, err := c.GetProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfileResponse(rsp)
}

// QueryLogWithResponse request returning *QueryLogResponse
func (c *ClientWithResponses) QueryLogWithResponse(ctx context.Context, params *QueryLogParams, reqEditors ...RequestEditorFn) (*QueryLogResponse, error) {
	rsp, err := c.QueryLog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryLogResponse(rsp)
}

// QuerylogClearWithResponse request returning *QuerylogClearResponse
func (c *ClientWithResponses) QuerylogClearWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QuerylogClearResponse, error) {
	rsp, err := c.QuerylogClear(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQuerylogClearResponse(rsp)
}

// QueryLogConfigWithBodyWithResponse request with arbitrary body returning *QueryLogConfigResponse
func (c *ClientWithResponses) QueryLogConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryLogConfigResponse, error) {
	rsp, err := c.QueryLogConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryLogConfigResponse(rsp)
}

func (c *ClientWithResponses) QueryLogConfigWithResponse(ctx context.Context, body QueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryLogConfigResponse, error) {
	rsp, err := c.QueryLogConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryLogConfigResponse(rsp)
}

// QueryLogInfoWithResponse request returning *QueryLogInfoResponse
func (c *ClientWithResponses) QueryLogInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueryLogInfoResponse, error) {
	rsp, err := c.QueryLogInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryLogInfoResponse(rsp)
}

// RewriteAddWithBodyWithResponse request with arbitrary body returning *RewriteAddResponse
func (c *ClientWithResponses) RewriteAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteAddResponse, error) {
	rsp, err := c.RewriteAddWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteAddResponse(rsp)
}

func (c *ClientWithResponses) RewriteAddWithResponse(ctx context.Context, body RewriteAddJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteAddResponse, error) {
	rsp, err := c.RewriteAdd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteAddResponse(rsp)
}

// RewriteDeleteWithBodyWithResponse request with arbitrary body returning *RewriteDeleteResponse
func (c *ClientWithResponses) RewriteDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteDeleteResponse, error) {
	rsp, err := c.RewriteDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteDeleteResponse(rsp)
}

func (c *ClientWithResponses) RewriteDeleteWithResponse(ctx context.Context, body RewriteDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteDeleteResponse, error) {
	rsp, err := c.RewriteDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteDeleteResponse(rsp)
}

// RewriteListWithResponse request returning *RewriteListResponse
func (c *ClientWithResponses) RewriteListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RewriteListResponse, error) {
	rsp, err := c.RewriteList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteListResponse(rsp)
}

// SafebrowsingDisableWithResponse request returning *SafebrowsingDisableResponse
func (c *ClientWithResponses) SafebrowsingDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingDisableResponse, error) {
	rsp, err := c.SafebrowsingDisable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafebrowsingDisableResponse(rsp)
}

// SafebrowsingEnableWithResponse request returning *SafebrowsingEnableResponse
func (c *ClientWithResponses) SafebrowsingEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingEnableResponse, error) {
	rsp, err := c.SafebrowsingEnable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafebrowsingEnableResponse(rsp)
}

// SafebrowsingStatusWithResponse request returning *SafebrowsingStatusResponse
func (c *ClientWithResponses) SafebrowsingStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingStatusResponse, error) {
	rsp, err := c.SafebrowsingStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafebrowsingStatusResponse(rsp)
}

// SafesearchDisableWithResponse request returning *SafesearchDisableResponse
func (c *ClientWithResponses) SafesearchDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchDisableResponse, error) {
	rsp, err := c.SafesearchDisable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafesearchDisableResponse(rsp)
}

// SafesearchEnableWithResponse request returning *SafesearchEnableResponse
func (c *ClientWithResponses) SafesearchEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchEnableResponse, error) {
	rsp, err := c.SafesearchEnable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafesearchEnableResponse(rsp)
}

// SafesearchStatusWithResponse request returning *SafesearchStatusResponse
func (c *ClientWithResponses) SafesearchStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchStatusResponse, error) {
	rsp, err := c.SafesearchStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafesearchStatusResponse(rsp)
}

// StatsWithResponse request returning *StatsResponse
func (c *ClientWithResponses) StatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsResponse, error) {
	rsp, err := c.Stats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsResponse(rsp)
}

// StatsConfigWithBodyWithResponse request with arbitrary body returning *StatsConfigResponse
func (c *ClientWithResponses) StatsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StatsConfigResponse, error) {
	rsp, err := c.StatsConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsConfigResponse(rsp)
}

func (c *ClientWithResponses) StatsConfigWithResponse(ctx context.Context, body StatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*StatsConfigResponse, error) {
	rsp, err := c.StatsConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsConfigResponse(rsp)
}

// StatsInfoWithResponse request returning *StatsInfoResponse
func (c *ClientWithResponses) StatsInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsInfoResponse, error) {
	rsp, err := c.StatsInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsInfoResponse(rsp)
}

// StatsResetWithResponse request returning *StatsResetResponse
func (c *ClientWithResponses) StatsResetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsResetResponse, error) {
	rsp, err := c.StatsReset(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsResetResponse(rsp)
}

// StatusWithResponse request returning *StatusResponse
func (c *ClientWithResponses) StatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusResponse, error) {
	rsp, err := c.Status(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatusResponse(rsp)
}

// TestUpstreamDNSWithBodyWithResponse request with arbitrary body returning *TestUpstreamDNSResponse
func (c *ClientWithResponses) TestUpstreamDNSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestUpstreamDNSResponse, error) {
	rsp, err := c.TestUpstreamDNSWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestUpstreamDNSResponse(rsp)
}

func (c *ClientWithResponses) TestUpstreamDNSWithResponse(ctx context.Context, body TestUpstreamDNSJSONRequestBody, reqEditors ...RequestEditorFn) (*TestUpstreamDNSResponse, error) {
	rsp, err := c.TestUpstreamDNS(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestUpstreamDNSResponse(rsp)
}

// TlsConfigureWithBodyWithResponse request with arbitrary body returning *TlsConfigureResponse
func (c *ClientWithResponses) TlsConfigureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TlsConfigureResponse, error) {
	rsp, err := c.TlsConfigureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsConfigureResponse(rsp)
}

func (c *ClientWithResponses) TlsConfigureWithResponse(ctx context.Context, body TlsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*TlsConfigureResponse, error) {
	rsp, err := c.TlsConfigure(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsConfigureResponse(rsp)
}

// TlsStatusWithResponse request returning *TlsStatusResponse
func (c *ClientWithResponses) TlsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TlsStatusResponse, error) {
	rsp, err := c.TlsStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsStatusResponse(rsp)
}

// TlsValidateWithBodyWithResponse request with arbitrary body returning *TlsValidateResponse
func (c *ClientWithResponses) TlsValidateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TlsValidateResponse, error) {
	rsp, err := c.TlsValidateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsValidateResponse(rsp)
}

func (c *ClientWithResponses) TlsValidateWithResponse(ctx context.Context, body TlsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*TlsValidateResponse, error) {
	rsp, err := c.TlsValidate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsValidateResponse(rsp)
}

// BeginUpdateWithResponse request returning *BeginUpdateResponse
func (c *ClientWithResponses) BeginUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BeginUpdateResponse, error) {
	rsp, err := c.BeginUpdate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBeginUpdateResponse(rsp)
}

// GetVersionJsonWithBodyWithResponse request with arbitrary body returning *GetVersionJsonResponse
func (c *ClientWithResponses) GetVersionJsonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVersionJsonResponse, error) {
	rsp, err := c.GetVersionJsonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionJsonResponse(rsp)
}

func (c *ClientWithResponses) GetVersionJsonWithResponse(ctx context.Context, body GetVersionJsonJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVersionJsonResponse, error) {
	rsp, err := c.GetVersionJson(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionJsonResponse(rsp)
}

// ParseAccessListResponse parses an HTTP response from a AccessListWithResponse call
func ParseAccessListResponse(rsp *http.Response) (*AccessListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccessListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessListResponseType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccessSetResponse parses an HTTP response from a AccessSetWithResponse call
func ParseAccessSetResponse(rsp *http.Response) (*AccessSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccessSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMobileConfigDoHResponse parses an HTTP response from a MobileConfigDoHWithResponse call
func ParseMobileConfigDoHResponse(rsp *http.Response) (*MobileConfigDoHResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MobileConfigDoHResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMobileConfigDoTResponse parses an HTTP response from a MobileConfigDoTWithResponse call
func ParseMobileConfigDoTResponse(rsp *http.Response) (*MobileConfigDoTResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MobileConfigDoTResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBlockedServicesAllResponse parses an HTTP response from a BlockedServicesAllWithResponse call
func ParseBlockedServicesAllResponse(rsp *http.Response) (*BlockedServicesAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedServicesAll
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockedServicesListResponse parses an HTTP response from a BlockedServicesListWithResponse call
func ParseBlockedServicesListResponse(rsp *http.Response) (*BlockedServicesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedServicesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockedServicesAvailableServicesResponse parses an HTTP response from a BlockedServicesAvailableServicesWithResponse call
func ParseBlockedServicesAvailableServicesResponse(rsp *http.Response) (*BlockedServicesAvailableServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesAvailableServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedServicesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockedServicesSetResponse parses an HTTP response from a BlockedServicesSetWithResponse call
func ParseBlockedServicesSetResponse(rsp *http.Response) (*BlockedServicesSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCacheClearResponse parses an HTTP response from a CacheClearWithResponse call
func ParseCacheClearResponse(rsp *http.Response) (*CacheClearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheClearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClientsStatusResponse parses an HTTP response from a ClientsStatusWithResponse call
func ParseClientsStatusResponse(rsp *http.Response) (*ClientsStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Clients
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClientsAddResponse parses an HTTP response from a ClientsAddWithResponse call
func ParseClientsAddResponse(rsp *http.Response) (*ClientsAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClientsDeleteResponse parses an HTTP response from a ClientsDeleteWithResponse call
func ParseClientsDeleteResponse(rsp *http.Response) (*ClientsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClientsFindResponse parses an HTTP response from a ClientsFindWithResponse call
func ParseClientsFindResponse(rsp *http.Response) (*ClientsFindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsFindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientsFindResponseType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClientsUpdateResponse parses an HTTP response from a ClientsUpdateWithResponse call
func ParseClientsUpdateResponse(rsp *http.Response) (*ClientsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDhcpAddStaticLeaseResponse parses an HTTP response from a DhcpAddStaticLeaseWithResponse call
func ParseDhcpAddStaticLeaseResponse(rsp *http.Response) (*DhcpAddStaticLeaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpAddStaticLeaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCheckActiveDhcpResponse parses an HTTP response from a CheckActiveDhcpWithResponse call
func ParseCheckActiveDhcpResponse(rsp *http.Response) (*CheckActiveDhcpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckActiveDhcpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DhcpSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpInterfacesResponse parses an HTTP response from a DhcpInterfacesWithResponse call
func ParseDhcpInterfacesResponse(rsp *http.Response) (*DhcpInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetInterfaces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDhcpRemoveStaticLeaseResponse parses an HTTP response from a DhcpRemoveStaticLeaseWithResponse call
func ParseDhcpRemoveStaticLeaseResponse(rsp *http.Response) (*DhcpRemoveStaticLeaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpRemoveStaticLeaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpResetResponse parses an HTTP response from a DhcpResetWithResponse call
func ParseDhcpResetResponse(rsp *http.Response) (*DhcpResetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpResetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpResetLeasesResponse parses an HTTP response from a DhcpResetLeasesWithResponse call
func ParseDhcpResetLeasesResponse(rsp *http.Response) (*DhcpResetLeasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpResetLeasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpSetConfigResponse parses an HTTP response from a DhcpSetConfigWithResponse call
func ParseDhcpSetConfigResponse(rsp *http.Response) (*DhcpSetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpSetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpStatusResponse parses an HTTP response from a DhcpStatusWithResponse call
func ParseDhcpStatusResponse(rsp *http.Response) (*DhcpStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DhcpStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDnsConfigResponse parses an HTTP response from a DnsConfigWithResponse call
func ParseDnsConfigResponse(rsp *http.Response) (*DnsConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDnsInfoResponse parses an HTTP response from a DnsInfoWithResponse call
func ParseDnsInfoResponse(rsp *http.Response) (*DnsInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			BlockingIpv4 *string                `json:"blocking_ipv4,omitempty"`
			BlockingIpv6 *string                `json:"blocking_ipv6,omitempty"`
			BlockingMode *DNSConfigBlockingMode `json:"blocking_mode,omitempty"`

			// BootstrapDns Bootstrap servers, port is optional after colon.  Empty value will reset it to default values.
			BootstrapDns             *[]string `json:"bootstrap_dns,omitempty"`
			CacheOptimistic          *bool     `json:"cache_optimistic,omitempty"`
			CacheSize                *int      `json:"cache_size,omitempty"`
			CacheTtlMax              *int      `json:"cache_ttl_max,omitempty"`
			CacheTtlMin              *int      `json:"cache_ttl_min,omitempty"`
			DefaultLocalPtrUpstreams *[]string `json:"default_local_ptr_upstreams,omitempty"`
			DhcpAvailable            *bool     `json:"dhcp_available,omitempty"`
			DisableIpv6              *bool     `json:"disable_ipv6,omitempty"`
			DnssecEnabled            *bool     `json:"dnssec_enabled,omitempty"`
			EdnsCsEnabled            *bool     `json:"edns_cs_enabled,omitempty"`

			// LocalPtrUpstreams Upstream servers, port is optional after colon.  Empty value will reset it to default values.
			LocalPtrUpstreams *[]string `json:"local_ptr_upstreams,omitempty"`
			ProtectionEnabled *bool     `json:"protection_enabled,omitempty"`
			Ratelimit         *int      `json:"ratelimit,omitempty"`
			ResolveClients    *bool     `json:"resolve_clients,omitempty"`

			// UpstreamDns Upstream servers, port is optional after colon.  Empty value will reset it to default values.
			UpstreamDns            *[]string    `json:"upstream_dns,omitempty"`
			UpstreamDnsFile        *string      `json:"upstream_dns_file,omitempty"`
			UpstreamMode           *interface{} `json:"upstream_mode,omitempty"`
			UsePrivatePtrResolvers *bool        `json:"use_private_ptr_resolvers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFilteringAddURLResponse parses an HTTP response from a FilteringAddURLWithResponse call
func ParseFilteringAddURLResponse(rsp *http.Response) (*FilteringAddURLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringAddURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringCheckHostResponse parses an HTTP response from a FilteringCheckHostWithResponse call
func ParseFilteringCheckHostResponse(rsp *http.Response) (*FilteringCheckHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringCheckHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterCheckHostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFilteringConfigResponse parses an HTTP response from a FilteringConfigWithResponse call
func ParseFilteringConfigResponse(rsp *http.Response) (*FilteringConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringRefreshResponse parses an HTTP response from a FilteringRefreshWithResponse call
func ParseFilteringRefreshResponse(rsp *http.Response) (*FilteringRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterRefreshResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFilteringRemoveURLResponse parses an HTTP response from a FilteringRemoveURLWithResponse call
func ParseFilteringRemoveURLResponse(rsp *http.Response) (*FilteringRemoveURLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringRemoveURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringSetRulesResponse parses an HTTP response from a FilteringSetRulesWithResponse call
func ParseFilteringSetRulesResponse(rsp *http.Response) (*FilteringSetRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringSetRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringSetURLResponse parses an HTTP response from a FilteringSetURLWithResponse call
func ParseFilteringSetURLResponse(rsp *http.Response) (*FilteringSetURLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringSetURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringStatusResponse parses an HTTP response from a FilteringStatusWithResponse call
func ParseFilteringStatusResponse(rsp *http.Response) (*FilteringStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChangeLanguageResponse parses an HTTP response from a ChangeLanguageWithResponse call
func ParseChangeLanguageResponse(rsp *http.Response) (*ChangeLanguageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeLanguageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCurrentLanguageResponse parses an HTTP response from a CurrentLanguageWithResponse call
func ParseCurrentLanguageResponse(rsp *http.Response) (*CurrentLanguageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentLanguageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LanguageSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallCheckConfigResponse parses an HTTP response from a InstallCheckConfigWithResponse call
func ParseInstallCheckConfigResponse(rsp *http.Response) (*InstallCheckConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallCheckConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallCheckConfigBetaResponse parses an HTTP response from a InstallCheckConfigBetaWithResponse call
func ParseInstallCheckConfigBetaResponse(rsp *http.Response) (*InstallCheckConfigBetaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallCheckConfigBetaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallConfigureResponse parses an HTTP response from a InstallConfigureWithResponse call
func ParseInstallConfigureResponse(rsp *http.Response) (*InstallConfigureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallConfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInstallConfigureBetaResponse parses an HTTP response from a InstallConfigureBetaWithResponse call
func ParseInstallConfigureBetaResponse(rsp *http.Response) (*InstallConfigureBetaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallConfigureBetaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInstallGetAddressesResponse parses an HTTP response from a InstallGetAddressesWithResponse call
func ParseInstallGetAddressesResponse(rsp *http.Response) (*InstallGetAddressesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallGetAddressesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddressesInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallGetAddressesBetaResponse parses an HTTP response from a InstallGetAddressesBetaWithResponse call
func ParseInstallGetAddressesBetaResponse(rsp *http.Response) (*InstallGetAddressesBetaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallGetAddressesBetaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddressesInfoBeta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseParentalDisableResponse parses an HTTP response from a ParentalDisableWithResponse call
func ParseParentalDisableResponse(rsp *http.Response) (*ParentalDisableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParentalDisableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseParentalEnableResponse parses an HTTP response from a ParentalEnableWithResponse call
func ParseParentalEnableResponse(rsp *http.Response) (*ParentalEnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParentalEnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseParentalStatusResponse parses an HTTP response from a ParentalStatusWithResponse call
func ParseParentalStatusResponse(rsp *http.Response) (*ParentalStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParentalStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Enable      *bool `json:"enable,omitempty"`
			Sensitivity *int  `json:"sensitivity,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProfileResponse parses an HTTP response from a GetProfileWithResponse call
func ParseGetProfileResponse(rsp *http.Response) (*GetProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseQueryLogResponse parses an HTTP response from a QueryLogWithResponse call
func ParseQueryLogResponse(rsp *http.Response) (*QueryLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseQuerylogClearResponse parses an HTTP response from a QuerylogClearWithResponse call
func ParseQuerylogClearResponse(rsp *http.Response) (*QuerylogClearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QuerylogClearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryLogConfigResponse parses an HTTP response from a QueryLogConfigWithResponse call
func ParseQueryLogConfigResponse(rsp *http.Response) (*QueryLogConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryLogConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryLogInfoResponse parses an HTTP response from a QueryLogInfoWithResponse call
func ParseQueryLogInfoResponse(rsp *http.Response) (*QueryLogInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryLogInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryLogConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRewriteAddResponse parses an HTTP response from a RewriteAddWithResponse call
func ParseRewriteAddResponse(rsp *http.Response) (*RewriteAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RewriteAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRewriteDeleteResponse parses an HTTP response from a RewriteDeleteWithResponse call
func ParseRewriteDeleteResponse(rsp *http.Response) (*RewriteDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RewriteDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRewriteListResponse parses an HTTP response from a RewriteListWithResponse call
func ParseRewriteListResponse(rsp *http.Response) (*RewriteListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RewriteListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RewriteList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSafebrowsingDisableResponse parses an HTTP response from a SafebrowsingDisableWithResponse call
func ParseSafebrowsingDisableResponse(rsp *http.Response) (*SafebrowsingDisableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafebrowsingDisableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafebrowsingEnableResponse parses an HTTP response from a SafebrowsingEnableWithResponse call
func ParseSafebrowsingEnableResponse(rsp *http.Response) (*SafebrowsingEnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafebrowsingEnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafebrowsingStatusResponse parses an HTTP response from a SafebrowsingStatusWithResponse call
func ParseSafebrowsingStatusResponse(rsp *http.Response) (*SafebrowsingStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafebrowsingStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Enabled *bool `json:"enabled,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSafesearchDisableResponse parses an HTTP response from a SafesearchDisableWithResponse call
func ParseSafesearchDisableResponse(rsp *http.Response) (*SafesearchDisableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafesearchDisableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafesearchEnableResponse parses an HTTP response from a SafesearchEnableWithResponse call
func ParseSafesearchEnableResponse(rsp *http.Response) (*SafesearchEnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafesearchEnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafesearchStatusResponse parses an HTTP response from a SafesearchStatusWithResponse call
func ParseSafesearchStatusResponse(rsp *http.Response) (*SafesearchStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafesearchStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Enabled *bool `json:"enabled,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStatsResponse parses an HTTP response from a StatsWithResponse call
func ParseStatsResponse(rsp *http.Response) (*StatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStatsConfigResponse parses an HTTP response from a StatsConfigWithResponse call
func ParseStatsConfigResponse(rsp *http.Response) (*StatsConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatsInfoResponse parses an HTTP response from a StatsInfoWithResponse call
func ParseStatsInfoResponse(rsp *http.Response) (*StatsInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStatsResetResponse parses an HTTP response from a StatsResetWithResponse call
func ParseStatsResetResponse(rsp *http.Response) (*StatsResetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsResetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatusResponse parses an HTTP response from a StatusWithResponse call
func ParseStatusResponse(rsp *http.Response) (*StatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestUpstreamDNSResponse parses an HTTP response from a TestUpstreamDNSWithResponse call
func ParseTestUpstreamDNSResponse(rsp *http.Response) (*TestUpstreamDNSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestUpstreamDNSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpstreamsConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTlsConfigureResponse parses an HTTP response from a TlsConfigureWithResponse call
func ParseTlsConfigureResponse(rsp *http.Response) (*TlsConfigureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TlsConfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TlsConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTlsStatusResponse parses an HTTP response from a TlsStatusWithResponse call
func ParseTlsStatusResponse(rsp *http.Response) (*TlsStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TlsStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TlsConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTlsValidateResponse parses an HTTP response from a TlsValidateWithResponse call
func ParseTlsValidateResponse(rsp *http.Response) (*TlsValidateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TlsValidateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TlsConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBeginUpdateResponse parses an HTTP response from a BeginUpdateWithResponse call
func ParseBeginUpdateResponse(rsp *http.Response) (*BeginUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BeginUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVersionJsonResponse parses an HTTP response from a GetVersionJsonWithResponse call
func ParseGetVersionJsonResponse(rsp *http.Response) (*GetVersionJsonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionJsonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"S/82aTtSZ9jH64//PwAA///N/3++O+UAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
